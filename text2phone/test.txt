पाइथन में प्रोग्रामिंग, डेटा स्ट्रक्चर्स और एल्गोरिदम पर पाठ्यक्रम पर पहले व्याख्यान में, आपका स्वागत है
आइए हम एक एल्गोरिथ्म और प्रोग्रामिंग क्या है, की मूल परिभाषा के साथ शुरू करते हैं
जैसा कि आप में से अधिकांश शायद जानते हैं, कि एक अल्गोरिथम एक विवरण है, कि कैसे व्यवस्थित रूप से कुछ टास्क करना है
तो, एक अल्गोरिथम में स्टेप्स का एक सीक्वेंस होता है
जिसे हम कुछ हासिल करने के लिए एक रेसिपी के रूप में सोच सकते हैं
तो, पाठ्यक्रम का शब्द रेसिपी खाना पकाने से आता है
जहां हमारे पास लिस्ट ऑफ़ इंग्रेडिएंट्स है, और फिर एक डिश तैयार करने के लिए स्टेप्स का एक सीक्वेंस है
तो, उसी तरह एक अल्गोरिथम कुछ तैयार करने, या दिए गए टास्क को प्राप्त करने का एक तरीका है
इसलिए, हमारी बात के संदर्भ में, एक रेसिपी जिसे हम एक प्रोग्राम कहते हैं
और हम एक प्रोग्रामिंग लैंग्वेज का उपयोग करके, एक प्रोग्राम लिखते हैं
तो, एक प्रोग्रामिंग लैंग्वेज का लक्ष्य, आवश्यक स्टेप्स के सीक्वेंस का वर्णन करने में सक्षम होना है
और यह भी वर्णन करने के लिए, कि अगर बीच में अलग अलग चीजें होती हैं, तो हम स्टेप्स के विभिन्न दृश्यों को कैसे आगे बढ़ा सकते हैं
तो, एक स्टेप की धारणा कुछ ऐसी है, जो एल्गोरिथ्म को एक्सेक्यूट करने वाले द्वारा की जा सकती है
अब, एक प्रोग्राम को सिर्फ मशीन द्वारा एक्सेक्यूट नहीं किया जाना चाहिए
हालांकि यह कंप्यूटर प्रोग्रामिंग का विशिष्ट संदर्भ होगा, जहां हम एक कंप्यूटर से, अपने स्टेप्स को एक्सेक्यूट करने की उम्मीद करते हैं
एक प्रोग्राम को एक व्यक्ति द्वारा एक्सेक्यूट भी किया जा सकता है
उदाहरण के लिए, हाथ में काम, एक समारोह के लिए एक हॉल तैयार करना है
तो, इसमें कमरे की सफाई जैसे विभिन्न स्टेप्स शामिल होंगे
मंच तैयार करना, यह सुनिश्चित करना कि सजावट सही है
कुर्सियों की व्यवस्था करना, और इसी तरह
इसे लोगों की एक टीम द्वारा एक्सेक्यूट किया जाएगा
अब, विशेषज्ञता और लोगों के इस समूह के अनुभव के आधार पर
आप विस्तार के विभिन्न स्तरों पर, इस अल्गोरिथम का वर्णन कर सकते हैं
उदाहरण के लिए, कुर्सियों की व्यवस्था जैसे निर्देश से यह समझ में आएगा, कि इसमें शामिल लोग जानते हैं, कि वास्तव में क्या उम्मीद है
दूसरी ओर, यह उन लोगों का एक नया समूह है, जिन्होंने पहले कभी ऐसा नहीं किया
आपको इस स्टेप्स का अधिक विस्तार से वर्णन करने की आवश्यकता हो सकती है
उदाहरण के लिए, आप यह कहना चाह सकते हैं, कि कुर्सियों को आठ पंक्तियों में व्यवस्थित करें, और प्रत्येक पंक्ति में दस कुर्सियाँ डालें
तो, एक स्टेप की धारणा सब्जेक्टिव है
यह इस बात पर निर्भर करता है, कि हम उस व्यक्ति या मशीन की क्या उम्मीद करते हैं, जो अल्गोरिथम को एक्सेक्यूट कर रहा है
और उस क्षमता के संदर्भ में हम एल्गोरिथ्म का वर्णन करते हैं
इस पाठ्यक्रम में हमारा ध्यान कंप्यूटर एल्गोरिदम पर जा रहा है
और आमतौर पर, ये अल्गोरिथ्म्स इनफार्मेशन मनिप्युलेट करते हैं
सबसे बेसिक प्रकार का अल्गोरिथम, जो हम सभी हाई स्कूल से परिचित हैं, एक अल्गोरिथम है, जो न्यूमेरिकल फंक्शन्स कंप्यूट करता है
उदाहरण के लिए, हमारे पास एक अल्गोरिथम हो सकता है, जो दो नंबर्स, एक्स एंड वाई लेता है
और एक्स की पावर वाई को कंप्यूट करता है
इसलिए, हमने स्कूल में ऐसे कई फंक्शन्स देखे हैं
उदाहरण के लिए, एक्स के स्क्वायर रुट की कम्प्यूटेशन करने के लिए, तो हम स्कूल में क्या करते हैं
क्या हमारे पास, एक्स के स्क्वायर रुट की कम्प्यूटेशन करने का एक जटिल तरीका है
या एक्स डिवाइडेड बाई वाई हो सकते हैं, जहां हम इस लॉन्ग डिवीज़न पर करते हैं, है ना
तो, ये सभी अल्गोरिथ्म्स हैं, जो एक या अधिक नंबर्स में दिए गए वैल्यूज कंप्यूट करते हैं, जो वे इस कार्य के आउटपुट कंप्यूट करते हैं
लेकिन, हम सभी जिन्होंने कम्प्यूटर्स का उपयोग किया है, वे जानते हैं, कि कई अन्य चीजें भी कम्प्यूटेशन के दायरे में आती हैं
उदाहरण के लिए, यदि हम जानकारी की व्यवस्था करने के लिए एक स्प्रेड शीट का उपयोग करते हैं
और फिर हम एक कॉलम सॉर्टेड चाहते हैं
इसलिए, इसमें किसी क्रम में कॉलम में, आइटम्स को पुनर्व्यवस्थित करना शामिल है
या तो असेंडिंग आर्डर में, या डेस्केन्डिंग आर्डर में
तो, इनफार्मेशन को पुनर्गठित करना भी एक कम्प्यूटेशनल टास्क है
और हमें यह जानने की जरूरत है, कि यह कैसे किया जाए
हम अपने जीवन में, हमारे आसपास की कंप्यूटेशन्स भी देखते हैं
उदाहरण के लिए, जब हम एक यात्रा बुकिंग साइट पर जाते हैं
और हम एक शहर से दूसरे शहर की उड़ान बुक करने की कोशिश करते हैं
यह मिनिमम टाइम या मिनिमम कॉस्ट के संदर्भ में, उड़ानों की व्यवस्था करने की पेशकश करेगा
तो, ये ऑप्टिमाइजेशन प्रोब्लेम्स हैं
इसमें किसी विशेष तरीके से जानकारी की व्यवस्था करना भी शामिल है
और फिर कुछ क्वांटिटी कंप्यूट करना, जो हम चाहते हैं
इस मामले में हम जानना चाहते हैं, कि हम ए से बी
सभी अलग अलग तरीकों से, हम ए से बी तक प्राप्त कर सकते हैं, हम इनमे से ऑप्टिमम चाहते हैं
और निश्चित रूप से, बहुत बहुत अधिक चीजें हैं, जिन्हें हम दिन प्रतिदिन देखते हैं, जिन्हें कम्प्यूटर्स प्रोग्राम द्वारा एक्सेक्यूट किया जाता है
हम उदाहरण के लिए गेम्स खेल सकते हैं
हम सुडोकु को हल कर सकते हैं, या हम एक प्रोग्राम के खिलाफ चैस खेल सकते हैं
जब हम डॉक्यूमेंट टाइप करने के लिए, वर्ड प्रोसेसर का उपयोग करते हैं
या यहां तक कि, जब हम अपने सेल फोन का उपयोग, एसएमएस संदेशों को टाइप करने के लिए करते हैं
कम्प्यूटर्स हमारी वर्तनी में सुधार का सुझाव देता है
तो, हम इस पाठ्यक्रम में इनमें से कुछ बातों को देखेंगे
लेकिन बात यह है, कि हमारे संदर्भ में एक प्रोग्राम कुछ भी है, जो जानकारी को देखता है
और इसे किसी दिए गए आवश्यकता में मैनिपुलेट करता है
इसलिए यह न केवल एक नंबर लेने, और एक नंबर आउट रखने का सवाल है
इसमें चीजों को पुनर्व्यवस्थित करना शामिल हो सकता है, यह कंप्यूटिंग को अधिक जटिल चीजों को शामिल कर सकता है
इसमें सूचनाओं को एक विशेष तरीके से व्यवस्थित करना शामिल हो सकता है, ताकि ये कंप्यूटेशन्स अधिक ट्रैक्टेबल हो सकें
और जिसे हम डेटा स्ट्रक्चर कहते हैं
इसलिए, इसका वर्णन करने के लिए, हम एक फंक्शन को देखते हैं, जिसे हम में से अधिकांश ने देखा है
और इसे एल्गोरिद्मिक रूप से समझने की कोशिश करें
तो, जिस संपत्ति की मैं कम्प्यूटेशन करना चाहता हूं, वह दो पॉजिटिव इंतेजरस एम और एन का ग्रेटेस्ट कॉमन डिवाइज़र है
इसलिए, जैसा कि हम जानते हैं, कि एक डिवाइज़र एक नंबर है, जो डिवाइड करती है
इसलिए, के एम का एक डिवाइज़र है, अगर मैं एम को के द्वारा डिवाइड कर सकता हूं, और कोई शेष नहीं पा सकता हूं
तो, एम और एन का ग्रेटेस्ट कॉमन डिवाइज़र, कुछ ऐसा होना चाहिए, जो एक कॉमन डिवाइज़र हो
तो, कॉमन का मतलब है, कि यह दोनों को डिवाइड करना चाहिए
और यह इनमें से सबसे बड़ा होना चाहिए
तो, यह सबसे बड़ा के है, जो एम को डिवाइड करता है, और के दिवाइड्स एन है
उदाहरण के लिए, यदि हम नंबर्स आठ और बारह को देखते हैं
फिर हम देख सकते हैं, कि चार आठ का फैक्टर है
चार आठ का डिवाइज़र है, चार बारह का भी डिवाइज़र है
बारह का एक और डिवाइज़र छह है, लेकिन छह आठ का डिवाइज़र नहीं है
तो, अगर हम आठ और बारह के डिवाइज़र्स से गुजरते हैं
यह देखना आसान है, कि सबसे बड़ी नंबर, जो आठ और बारह दोनों को डिवाइड करती है, चार है
तो, आठ और बारह का जीसीडी चार है
अठारह और पच्चीस का क्या है
पच्चीस पांच से पांच है, तो इसमें एक और पच्चीस के अलावा, केवल एक ही डिवाइज़र है, जो पाँच है, और पाँच अठारह का डिवाइज़र नहीं है
लेकिन, सौभाग्य से एक अठारह का एक डिवाइज़र है
तो, हम कह सकते हैं, कि अठारह और पच्चीस का जीसीडी एक है
एक से बड़ा कोई नंबर नहीं है, जो अठारह और पच्चीस दोनों को डिवाइड करता है
चूंकि, हर नंबर को हम अठारह और पच्चीस के मामले में देखते हैं
दो नंबरों में हमेशा कम से कम एक कॉमन डिवाइज़र रहेगा
तो, जीसीडी हमेशा अच्छी तरह से डिफ़ाइन किया जाएगा, यह कभी नहीं होगा, कि हम एक कॉमन डिवाइज़र नहीं पा सकते हैं
और क्योंकि सभी कॉमन डिवाइज़र नंबर्स हो सकते हैं, हम उन्हें सबसे छोटे से सबसे बड़े की व्यवस्था कर सकते हैं
और सबसे बड़ा ग्रेटेस्ट कॉमन डिवाइज़र के रूप में चुनें
तो, पॉजिटिव नंबर्स एम और एन की, किसी भी जोड़ी को देखते हुए
हम निश्चित रूप से, इन दो नंबरों के जीसीडी की कम्प्यूटेशन कर सकते हैं
तो, एम और एन के जीसीडी की कंप्यूटिंग के बारे में, कोई कैसे जाएगा
तो, यह वह जगह है, जहां हम अल्गोरिथ्मिक बिट में आते हैं
हम किसी भी एम और किसी भी एन के लिए, व्यवस्थित रूप से, कंप्यूटिंग जीसीडी के यूनिफार्म तरीके का वर्णन करना चाहते हैं
तो यहाँ एक बहुत ही सरल प्रक्रिया है, यह सबसे कुशल नहीं है, क्योंकि हम आगे जाके बेहतर देखेंगे
लेकिन, अगर हम सिर्फ जीसीडी की परिभाषा को देखें, तो यह कहता है, कि एम के सभी फैक्टर्स को देखें
एन के सभी फैक्टर्स को देखें, और सबसे बड़ा खोजें, जो दोनों का फैक्टर है
तो ऐसा करने का भोला तरीका, पहले नंबर एम के सभी फैक्टर्स को लिस्ट करना होगा
फिर दूसरे नंबर एन के सभी फैक्टर्स को लिस्ट बद्ध करें
और फिर इन दोनों लिस्ट्स में सबसे बड़ी नंबर्स है, जो दोनों लिस्ट्स में दिखाई देती है
यह लगभग सचमुच जीसीडी की डेफिनिशन है
अब, सवाल यह है, कि क्या यह एक एल्गोरिथ्म है
ठीक है, विस्तार के एक उच्च स्तर पर, अगर हम लिस्ट के फैक्टर्स को, एक ही स्टेप के रूप में सोचते हैं
हम एक एल्गोरिथ्म से क्या चाहते हैं, दो चीजें हैं
एक यह है, कि क्या करना है, का विवरण एक फाइनाइट तरीके से लिखा जाना चाहिए
इस अर्थ में, कि मैं एम और एन के वैल्यूज की परवाह किए बिना, इन इंस्ट्रक्शंस को इस तरह लिख सकूं, कि आप इसे पढ़ सकें, और सभी के लिए समझ सकें
तो, यहाँ बहुत स्पष्ट है, कि हमारे पास ठीक तीन स्टेप्स हैं
इसलिए, हमारे पास तीन स्टेप्स हैं, जो अल्गोरिथम का गठन करते हैं
तो, यह निश्चित रूप से, एक फाइनाइट तरीके से प्रस्तुत किया गया है
एक अल्गोरिथम की अन्य आवश्यकता यह है, कि हमें फाइनाइट स्टेप्स के बाद जवाब मिलना चाहिए
अब, कदमों की यह फाइनाइट संख्या, एम और एन के विभिन्न वैल्यूज के लिए अलग हो सकता है
आप कल्पना कर सकते हैं, कि यदि आपके पास एम के लिए बहुत छोटा नंबर है, तो कई फैक्टर नहीं हैं
यदि आपके पास एम के लिए बहुत बड़ी नंबर है, तो आपके पास कई फैक्टर्स हो सकते हैं
तो, एम और एन के फैक्टर्स को सूचीबद्ध करने की प्रक्रिया में, लंबा समय लग सकता है
हालांकि हम गारंटी देना चाहते हैं, कि यह प्रक्रिया हमेशा समाप्त हो जाएगी
और फिर ऐसा करके
हम हमेशा सबसे बड़ा नंबर खोजने में सक्षम होंगे, जो दोनों लिस्ट्स में दिखाई देती है
इसलिए, यह तर्क देने के लिए, कि यह प्रक्रिया अच्छी तरह से परिभाषित है
हमें केवल यह महसूस करने की आवश्यकता है, कि एम के कारक, एक और एम के बीच होने चाहिए
दूसरे शब्दों में, हालांकि असीम रूप से कई अलग अलग संभावनाएं हैं, क्योंकि हम जो फैक्टर करते हैं, उन्हें एम से बड़ी किसी भी नंबर्स को नहीं देखना होगा
तो, हम को एम के फैक्टर्स कंप्यूट करने के लिए
एक से एम तक हर नंबर का परीक्षण करना होगा
और अगर यह एम को एक रिमाइंडर के बिना डिवाइड करता है, तो हम इसे फैक्टर्स की लिस्ट में जोड़ते हैं
इसलिए, हम फैक्टर्स की एक एम्प्टी लिस्ट के साथ शुरू करते हैं
और हम एम तक, एक, दो, तीन, चार बारी से विचार करते हैं
और ऐसी प्रत्येक नंबर के लिए हम जाँच करते हैं, कि क्या हम इस नंबर से एम को डिवाइड करते हैं, तो हमें शून्य का रिमाइंडर मिलता है
हमें रिमाइंडर शून्य मिलता है, जिसे हम लिस्ट में जोड़ते हैं
तो, आइए एक ठोस उदाहरण देखें, आइए हम चौदह और तिरसठ के जीसीडी की कम्प्यूटेशन करने का प्रयास करें
तो, हमारे अल्गोरिथम में पहला स्टेप, चौदह के फैक्टर्स की कम्प्यूटेशन करने के लिए कहता है
तो, चौदह के फैक्टर्स के ऊपर, हमारे अवलोकन से, एक और चौदह के बीच होना चाहिए, चौदह से बड़ा कुछ भी फैक्टर नहीं हो सकता है
इसलिए हम एक और चौदह के बीच, सभी संभावित फैक्टर्स को सूचीबद्ध करके, और उनका परीक्षण करके शुरू करते हैं
इसलिए, हम निश्चित रूप से जानते हैं, कि एक हमेशा डिवाइज़र होगा
इस मामले में, दो से चौदह डिवाइड होते हैं, क्योंकि दो से चौदह डिवाइड पर सात होते हैं, और कोई रिमाइंडर नहीं हैं
अब, तीन डिवाइड नहीं करता है
चार डिवाइड नहीं करता है
पांच डिवाइड नहीं करता, छह डिवाइड नहीं करता
लेकिन सात करता है, क्योंकि अगर हम चौदह को सात से डिवाइड करते हैं
हमें रिमाइंडर शून्य मिलता है
फिर आठ डिवाइड नहीं करता
नौ डिवाइड नहीं करता है, और इसी तरह
और अंत में, हम पाते हैं, कि केवल अन्य फैक्टर बचा है, चौदह ही
सही है, इसलिए, हर नंबर एम के, वन एंड एम फैक्टर्स होंगे, और फिर बीच में फैक्टर्स हो सकते हैं
इसलिए, ऐसा करने के बाद, हमने अब चौदह के फैक्टर्स की पहचान की है
और ये फैक्टर्स ठीक एक, दो, सात, और चौदह हैं
तो, चौदह और तिरसठ के जीसीडी की कम्प्यूटेशन में अगला स्टेप, तिरसठ के फैक्टर्स की कम्प्यूटेशन करना है
तो, उसी तरह हम एक से तिरसठ तक सारे नम्बर लिख देते हैं
और हम जाँच करते हैं, कि कौन से डिवाइज़र्स हैं, तो फिर से हम पाएंगे कि एक डिवाइड करता है
यहां, दो डिवाइड नहीं करता, क्योंकि तिरसठ भी नहीं होता, तीन डिवाइड करता है
फिर हमें यहां संख्याओं का एक गुच्छा मिलेगा, जो कि डिवाइड नहीं करता है
और फिर हम पाएंगे कि सात डिवाइज़र हैं, क्योंकि सात नाइन तिरसठ हैं
फिर आठ डिवाइड नहीं करता
लेकिन नौ करता है
फिर से संख्याओं का एक बड़ा अंतर होता है, जो कि डिवाइड नहीं करता है
और फिर इक्कीस डिवाइड करता है, क्योंकि इक्कीस तीन तिरसठ है
और फिर अंत में हम पाते हैं, कि हमारे पास अंतिम फैक्टर तिरसठ है
इसलिए, यदि हम प्रत्येक नंबर को पार करने के लिए, एक से तिरसठ तक व्यवस्थित रूप से इस से गुजरते हैं, जो फैक्टर्स नहीं है
हम लिस्ट में एक, तीन, सात, नौ, इक्कीस और तिरसठ के साथ समाप्त करते हैं
दो नंबर, चौदह और तिरसठ के फैक्टर्स कंप्यूट करके
हमारे अल्गोरिथम में अगला स्टेप कहता है, कि हमें सबसे बड़ा फैक्टर खोजना चाहिए, जो दोनों लिस्ट में दिखाई देता है
तो, हम ऐसा कैसे करते हैं
हम सामान्य फैक्टर्स की लिस्ट कैसे बनाते हैं
अब ऐसा करने के लिए, और अधिक चतुर तरीके हैं, लेकिन यहां एक बहुत ही सरल तरीका है
हम सिर्फ एक लिस्ट से गुजरते हैं, जो चौदह के फैक्टर्स की लिस्ट कहता है
और लिस्ट में प्रत्येक आइटम के लिए हम जांच करते हैं, कि क्या यह तिरसठ का फैक्टर है
इसलिए, हम एक के साथ शुरू करते हैं, और हम कहते हैं, कि एक तिरसठ के फैक्टर के रूप में दिखाई देता है
यह करता है, इसलिए हम इसे कॉमन फैक्टर्स की लिस्ट में जोड़ते हैं
फिर हम दो को देखते हैं, और फिर हम पूछते हैं, कि क्या ऐसा प्रतीत होता है, कि यह दिखाई नहीं देता है, इसलिए हम इसे छोड़ देते हैं
फिर हम तीन को देखते हैं
सात को देखें और हम पाते हैं, कि सात दिखाई देते हैं
तो, हम सात जोड़ते हैं, फिर अंत में हम चौदह को देखते हैं
और पाते हैं, कि चौदह दिखाई नहीं देता है, इसलिए हम इसे छोड़ देते हैं
तो इस तरह, हम व्यवस्थित रूप से एक से गुजरे हैं
दो
सात और चौदह
और निष्कर्ष निकाला कि इनमें से केवल एक और सात, दोनों लिस्ट्स में दिखाई देते हैं
और अब ऐसा करने के बाद, हमारे पास सभी कॉमन फैक्टर की लिस्ट है
हमने उनकी कम्प्यूटेशन सबसे छोटे से बड़े तक की, क्योंकि हम असेंडिंग आर्डर चौदह के फैक्टर्स से गुज़रे
तो, यह लिस्ट असेंडिंग आर्डर में भी होगी
इसलिए, सबसे बड़ा फैक्टर लौटाना, सिर्फ सात की इस लिस्ट में, सबसे राइटमोस्ट फैक्टर है
तो, यह हमारे कार्य का आउटपुट है, तो, हमने चौदह के फैक्टर्स की कम्प्यूटेशन की है, तिरसठ के फैक्टर्स की कम्प्यूटेशन की है
चौदह के हर फैक्टर्स के लिए व्यवस्थित रूप से जाँच की, कि क्या यह भी तिरसठ का फैक्टर है
और इस लिस्ट से, कॉमन फैक्टर की इस लिस्ट की कम्प्यूटेशन की
हमने सबसे बड़ा एक निकाला है, और यह वास्तव में हमारा जीसीडी है
तो, यह एक उदाहरण है, कि यह अल्गोरिथम कैसे एक्सेक्यूट करेगा
इसलिए यदि आपको इसे थोड़ा और विस्तार से लिखना था
तब हम कह सकते थे
हमें यह ध्यान देने की आवश्यकता है, कि हमें इन लिस्ट्स को याद रखने की आवश्यकता है
और फिर उनके पास वापस आओ, इसलिए हमें चौदह के फैक्टर्स कंप्यूट करने की आवश्यकता है, जो हमें इसे कहीं लिखने की आवश्यकता है
हमें तिरसठ के फैक्टर्स कम्प्यूट करने की आवश्यकता है, इसे कहीं लिखें और फिर इन दोनों लिस्ट्स की तुलना करें
इसलिए, दूसरे शब्दों में हमें इन्हें स्टोर करने के लिए, कुछ नेम्स असाइन करने की आवश्यकता है
तो आइए इन लिस्ट्स के नेम्स के रूप में, एन के फैक्टर्स के एफ एन एम के फैक्टर्स के लिए, एफ एम को कॉल करें
तो, हम क्या करते हैं, कि हम नंबर्स एक से एम तक चलते हैं
और इस लिस्ट, एक से एम मैं प्रत्येक आई के लिए
हम जांच करते हैं, कि क्या आई एम को डिवाइड करता है
क्या आई द्वारा एम डिवाइडेड शून्य रिमाइंडर है, और अगर ऐसा है, तो हमने एफ एम की लिस्ट फैक्टर्स में जोड़ा
इसी तरह, एक से एन तक प्रत्येक जे के लिए
हम जाँच करते हैं, कि क्या जे एन को डिवाइड करता है, और यदि हां, तो हम इसे लिस्ट एफ एन में जोड़ते हैं
अब हमारे पास दो लिस्ट्स एफ एम एंड एफ एन हैं, जो एम और एन के फैक्टर्स हैं
अब, हम कॉमन फैक्टर्स की लिस्ट कंप्यूट करना चाहते हैं, जिन्हें हम सी एफ कहेंगे
तो, हम जो करते हैं, वह हर एफ के लिए है, जो पहले नंबर का फैक्टर है
हमारे मामले में याद रखें यह चौदह था
प्रत्येक एफ के लिए, इसलिए हम अपने मामले में एक, दो, सात और चौदह से गुजरे
इसलिए, इस लिस्ट में प्रत्येक एफ के लिए, हम कॉमन फैक्टर्स की लिस्ट में एफ जोड़ते हैं
यदि यह दूसरी लिस्ट में भी दिखाई देता है, तो दूसरी लिस्ट में यदि आपको याद है, कि एक, तीन, सात, नौ, इक्कीस और साठ तीन थे
इसलिए, हम इस लिस्ट के साथ एफ की तुलना करते हैं, और अगर हम इसे पाते हैं, तो हमने इसे सी एफ में जोड़ा
और ऐसा करने के बाद, अब हम कॉमन फैक्टर्स की लिस्ट में सबसे बड़ा वैल्यू वापस करना चाहते हैं
याद रखें कि एक हमेशा एक कॉमन फैक्टर होगा, इसलिए लिस्ट सी एफ खाली नहीं होगा
इसलिए, कम से कम एक वैल्यू होगा, लेकिन चूंकि हम उन्हें असेंडिंग ऑर्डर्स में ऐड किये, क्योंकि लिस्ट एफ एम और एफ एन का निर्माण, एक से एम और एक एन से किया गया था
सबसे बड़ा वैल्यू राइटमोस्ट वैल्यू होगा
तो, यह हमें जीसीडी के लिए थोड़ा और विस्तृत एल्गोरिथ्म देता है
इसके कमोबेश पिछले वाले के समान ही है, सिवाय इसके कि यह थोड़ा और विस्तार से बताता है, कि एम के फैक्टर्स की लिस्ट कंप्यूट कैसे करें
एन के फैक्टर्स की लिस्ट कंप्यूट कैसे करें, और इन दोनों सूचियों के बीच सबसे बड़े सामान्य फैक्टर्स कंप्यूट कैसे करें
इसलिए, पहले हमारे पास तीन स्टेटमेंट्स थे, अब हमने इसे छह से अधिक विस्तृत स्टेटमेंट्स में विस्तारित किया है
तो, यह पहले से ही हमें अपना पहला पाइथन प्रोग्राम लिखने के लिए पर्याप्त जानकारी देता है
बेशक, हमें इसे लिखने से पहले थोड़ा और सीखने की आवश्यकता होगी
लेकिन हम निश्चित रूप से यह पता लगा सकते हैं, कि इसे कैसे पढ़ा जाए
तो यह पाइथन प्रोग्राम क्या कर रहा है, ठीक वही है, जो हमने पिछले स्टेप में अनौपचारिक रूप से वर्णित किया था
तो, पाइथन प्रोग्राम में पहली बात एक पंक्ति है, जो फंक्शन को डिफाइन करती है, तो, हम एम कॉमा एन के एक फंक्शन जीसीडी को परिभाषित कर रहे हैं
तो, एम और एन दो आर्गुमेंट हैं, जो किसी भी फंक्शन की तरह कोई भी नंबर हो सकते हैं, जो जब आप गणित में एफ ऑफ़ एक्स वाई लिखते हैं, तो इसका मतलब है, कि एक्स और वाई मनमाने वैल्यू हैं, और एव्री एक्स एंड वाई उन वैल्यूों के आधार पर कुछ करते हैं, जिन्हें आप फंक्शन के साथ कहते हैं
तो, यह कहता है, कि यह हमारी डेफिनिशन है, इसलिए डेफिनिशन के लिए डेफ
एक फंक्शन जीसीडी एम एन
तो, अब पहला स्टेप एम के फैक्टर्स की लिस्ट कंप्यूट करना है
पाइथन में हम स्क्वायर ब्रैकेट्स का उपयोग करके एक लिस्ट लिखते हैं
तो, लिस्ट एक्स, वाई, जेड और कई पर लिखी गई है
तो, एम्प्टी लिस्ट सिर्फ एक ओपन ब्रैकेट और एक स्क्वायर क्लोज्ड ब्रैकेट है
इसलिए, हम फैक्टर्स की एक एम्प्टी लिस्ट के साथ शुरू करते हैं, ताकि इस इक्वालिटी का मतलब है, एक वैल्यू असाइन करना
तो, हम खाली लिस्ट होने के लिए एम के फैक्टर्स की लिस्ट एफ एम असाइन करते हैं
अब, हमें रेंज वन से एन में, हर वैल्यू का परीक्षण करने की आवश्यकता है
अब, पाइथन के पास रेंज नामक एक बिल्टइन फंक्शन है
हम इसे देखेंगे
पाइथन की ख़ासियत के कारण, यह आपके द्वारा अपेक्षित रेंज नहीं है, बल्कि एक कम है
इसलिए, अगर मैं कहता हूं कि मुझे रेंज वन से एम प्लस वन में नंबर्स दें
यह मुझे रेंज वन टू एम में नंबर्स देता है
एक अपर लिमिट तक, लेकिन अपर लिमिट को शामिल नहीं करता
तो यह कहेगा कि आई वैल्यूज एक, दो, तीन से एम तक ले सकता हैं
आई के इन वैल्यूज में से प्रत्येक के लिए जाँच करें, कि क्या यह ट्रू है
अब परसेंटेज रिमाइंडर ऑपरेशन है
इसलिए, यह जांचता है, कि क्या आई द्वारा एम डिवाइड का रिमाइंडर शून्य है
यदि आई द्वारा एम डिवाइड का रिमाइंडर शून्य है, तो हम आई एक लिस्ट एफ एम में जोड़ देंगे, हम इसे अपेण्ड से करेंगे, यह एक इंग्लिश वर्ड है
जिसका मतलब है, कि लिस्ट के अंत में जोड़ें, इसलिए आई को एन से अपेण्ड करते हैं
इसलिए, इस स्टेप में हमने एफ एम कंप्यूट किया है, यह वही है, जो हमने पिछले उदाहरण में अनौपचारिक रूप से लिखा था
हमने सिर्फ इतना कहा कि एक से एम प्रत्येक आई जोड़ देता हूं, अगर आई एम को डिवाइड करता हैं
और अब हमने इसे पायथन सिंटैक्स में किया है
तो, हमने फैक्टर्स की एक खाली लिस्ट को डिफाइन किया है, और उस रेंज में प्रत्येक नंबर के लिए
हमने जाँच की है, कि क्या यह एक डिवाइज़र है, और फिर इसे जोड़ा
और अब यहाँ हम एन के लिए बिल्कुल यही काम करते हैं
तो, हम एम्प्टी लिस्ट के साथ शुरू करते हैं, और इस रेंज में प्रत्येक एन के फैक्टर जे के लिए
यदि यह डिवाइड करता है, तो हम इसे अपेण्ड करते हैं
और अब, इस बिंदु पर हमारे पास दो लिस्ट्स, एफ एम और एफ एन हैं
और अब हम कॉमन फैक्टर्स की लिस्ट कंप्यूट करना चाहते हैं
इसलिए, हम कॉमन फैक्टर्स की लिस्ट को दर्शाने के लिए, सी एफ का उपयोग करते हैं, शुरू में कोई कॉमन फैक्टर्स नहीं हैं
अब, पहली लिस्ट में हर फैक्टर के लिए
यदि फैक्टर दूसरी लिस्ट में दिखाई देता है, तो हम इसे सी एफ में अपेण्ड कर देते हैं
तो, एक ही फंक्शन अपेण्ड का उपयोग किया जा रहा है
यह कहता है, कि एक लिस्ट लें और एक वैल्यू जोड़ें
हम उस वैल्यू को जोड़ते हैं, जिसे हम अभी देख रहे हैं, बशर्ते कि यह कंडीशन को संतुष्ट करे
पहले हम जोड़ रहे थे, बशर्ते कि डिवाइज़र शून्य था
रिमाइंडर शून्य था, अब हम इसे जोड़ रहे हैं, बशर्ते दोनों लिस्ट में दिखाई दें
पहली लिस्ट में प्रत्येक एफ के लिए, यदि यह दूसरी लिस्ट में दिखाई देता है, तो इसे जोड़ें
तो, इसके बाद हमने एफ एम कंप्यूट की है
सी एफ
और अब हम राइटमोस्ट एलिमेंट चाहते हैं
तो, यह सिर्फ कुछ पाइथन सिंटेक्स है, जिसे आप देखेंगे जो कहता है कि
इसके बजाय यदि हम बाईं ओर से काउंट शुरू करते हैं, तो लिस्ट में पोसिशन्स की नंबर, शून्य, एक, दो, तीन, चार होती है
लेकिन पाइथन के पास एक शॉर्टकट है, जो कहता है, कि यदि आप दाईं ओर से काउंट करना चाहते हैं, तो हम संख्याओं को माइनस एक, माइनस दो, और इतने पर गिनते हैं
तो यह कहता है, कि सी एफ का माइनस वन्थ एलिमेंट लौटाएं जो पाइथन जारगन में है, जिसका अर्थ है, राइटमोस्ट एलिमेंट लौटाएं, तो यह राइटमोस्ट एलिमेंट है
तो, इस बिंदु पर यह समझने सकते है, कि हम वास्तव में कोशिश कर सकते हैं, और इस प्रोग्राम कोड को डी कोड कर सकते है
भले ही हम ठीक से समझ नहीं पा रहे हों, कि हम कुछ जगहों पर कोलन का इस्तेमाल क्यों कर रहे हैं, और क्यों कुछ बातों को आगे बढ़ा रहे हैं
देखें कि यहां अन्य सिंटैक्टिक चीजें हैं
तो, उदाहरण के लिए, आपके पास ये पंक्चुएशन मार्क्स हैं, जो इन कोलोन्स की तरह थोड़े अजीब हैं
फिर आपके पास यह तथ्य है, कि यह रेखा इस रेखा के संबंध में इंडेंटेड है
यह लाइन इस लाइन के संबंध में इंडेंटेड है, तो ये सभी विशेषताएं हैं, जो अन्य भाषाओं के प्रोग्राम्स की तुलना में पाइथन प्रोग्राम्स को पढ़ने और लिखने में थोड़ा आसान बनाती हैं
इसलिए, हम इन पर आएंगे, जब हम पायथन सिंटैक्स को अधिक औपचारिक रूप से सीखेंगे, परन्तु
इस बिंदु पर, हमें खुद को यह समझाने में सक्षम होना चाहिए, कि पायथन स्टेप्स का यह सेट अनौपचारिक अल्गोरिथम का एक बहुत ही वफादार प्रतिपादन है, जो हमने पिछली स्लाइड में लिखा था
तो चलिए कुछ पॉइंट्स पर ध्यान दें, कि हम पहले से ही इस विशेष उदाहरण से निकाल सकते हैं
इसलिए, पहला महत्वपूर्ण पॉइंट यह है, कि हमें इंटरमीडिएट वैल्यूज पर नज़र रखने के लिए एक तरीका चाहिए
इसलिए, हमारे पास अपने आर्ग्यूमेंट्स एम और एन के नेम्स के साथ शुरू करने के लिए दो नेम्स हैं
फिर हम इन तीन नेम्स का उपयोग, फैक्टर्स और सामान्य फैक्टर्स की इन सूचियों की कम्प्यूटेशन करने के लिए करते हैं
और हम अन्य नेम्स का उपयोग करते हैं, जैसे आई, जे, एंड एफ, इनसे चलाने के लिए, एक से एम तक चलने के लिए हमें आई की आवश्यकता है
हमें जे को एक से एन तक चलाने की जरूरत है, हम आई पुनउपयोग कर सकते हैं, लेकिन यह ठीक है
हम सी एफ में सभी फैक्टर्स से चलाने के लिए, एफ का उपयोग करते हैं
तो, ये सभी इंटरमीडिएट वैल्यूज पर नज़र रखने के तरीके हैं
ध्यान देने योग्य दूसरा पॉइंट यह है, कि एक वैल्यू एक ही आइटम हो सकता है
उदाहरण के लिए, एम, एन नंबर हैं
इसी तरह, मैं, जे और एफ प्रत्येक स्टेप में नंबर्स हैं
ये सिंगल वैल्यूज हो सकते हैं
या वे संग्रह हो सकते हैं, तो लिस्ट्स हैं
तो, एफ एम एक लिस्ट है, एफ एन एक लिस्ट है
तो, यह इस मामले में वैल्यूज के कलेक्शन को दर्शाने वाला एक सिंगल नेम है, एक लिस्ट, एक सीक्वेंस इसमें पहली पोसिशन और अगली पोसिशन और एक अंतिम पोसिशन है
तो, ये संख्याओं की लिस्ट हैं
अन्य कलेक्शंस की कल्पना कर सकते हैं, और हम उन्हें देखेंगे
तो, कलेक्शंस महत्वपूर्ण हैं, क्योंकि प्रोग्राम लिखना बहुत मुश्किल होगा
यदि हमें अलग से एम के हर फैक्टर के लिए, एक नेम का उत्पादन करते रहना था, तो हमें एम के सभी फैक्टर्सों के लिए सामूहिक रूप से, एक नेम की आवश्यकता होती है, भले ही एम कितना बड़ा हो
इसलिए, ये नेम्स सिंगल वैल्यू या वैल्यूज के कलेक्शंस को दर्शाते हैं, और एक विशेष स्ट्रक्चर के साथ वैल्यूज का एक कलेक्शंस ठीक वही है, जिसे हम डेटा स्ट्रक्चर कहते हैं
इसलिए, इन्हें आमतौर पर डेटा स्ट्रक्चर कहा जाता है, तो, इस मामले में डाटा स्ट्रक्चर जो हमारे पास है, वह एक लिस्ट है
तो, हम इन नेम्स और वैल्यूज का क्या कर सकते हैं, एक बात यह है, कि हम एक नेम्स के लिए एक वैल्यू असाइन कर सकते हैं
इसलिए, उदाहरण के लिए, जब हम लिखते हैं, कि एफ एन खाली लिस्ट के बराबर है, तो हम स्पष्ट रूप से एफ एन के वैल्यू को खाली लिस्ट में स्थापित कर रहे हैं
यह दो बातों को बताता है, कि वैल्यू एक खाली लिस्ट है, यह पाइथन को यह भी बताता है, कि एफ एन एक लिस्ट है
तो, ये दो स्टेप्स हैं, जैसा हम देखेंगे
और दूसरा हिस्सा यह है, कि जब हम कुछ ऐसा लिखते हैं, लिस्ट सी एफ में प्रत्येक एफ के लिए
यह स्पष्ट रूप से कह रहा है, कि सी एफ में हर वैल्यू लें और इसे एक एक करके वैल्यू एफ का नेम दें
इसलिए, हालांकि हमारे पास यह इक्वालिटी का संकेत स्पष्ट रूप से नहीं है, यह एफ के लिए एक नया वैल्यू असाइन कर रहा है, क्योंकि हम लिस्ट सी एफ के स्टेप्स से देखते हैं
तो, मुख्य बात यह है, कि हम एक पाइथन प्रोग्राम में वैल्यूज को नेम्स को असाइन करते हैं
और एक वैल्यू असाइन होने के बाद, हम वैल्यू को संशोधित कर सकते हैं
उदाहरण के लिए, हर बार जब हम एन का एक नया फैक्टर ढूंढते हैं, तो हम पुराने फैक्टर को फेंक देना नहीं चाहते हैं, उसे हम मौजूदा लिस्ट एफ एन से जोड़ लेना चाहते हैं
इसलिए, उदाहरण के लिए, यह कार्य एफ एन नेम के वैल्यू को एक नए नेम्स में संशोधित करता है, जो पुराने नेम को लेता है, और इसके अंत में आई को जोड़ता है
इसलिए, आम तौर पर हमारे पास एक नंबर आई हो सकती है, और हम इसे इसके दो गुना से बदलना चाहते हैं
इसलिए, हमारे पास कुछ ऐसा हो सकता है, जैसे मैं दो बार के बराबर हूं
तो, स्टार गुणा के लिए है
इसका मतलब यह नहीं है, कि यह दो बार आई अरिथमेटिकली के बराबर हैं
क्योंकि जाहिर है, जब तक आई शून्य नहीं होता, आई दो गुना के बराबर नहीं हो सकता
इसका मतलब यह है, कि आई का वर्तमान वैल्यू लें
इसे दो से गुणा करें और इसे आई को असाइन करें, इसलिए, हम इसे देखेंगे असाइन मेंट या तो पूरी तरह से नया वैल्यू असाइन कर सकता है, या यह पुराने वैल्यू का उपयोग करके वैल्यू को अपडेट कर सकता है
इसलिए यहां हम लिस्ट के फंक्शन का पुराना वैल्यू एफ एन ले रहे हैं
और हम इस से एक वैल्यू अपेण्ड कर रहे हैं, और एफ एन का एक नया वैल्यू प्राप्त कर रहे हैं
दूसरा हिस्सा जो हमें ध्यान देने की आवश्यकता है, कि हम हर स्टेप को कैसे एक्सेक्यूट करते हैं
तो जैसा कि हमने आज के व्याख्यान की शुरुआत में कहा था, एक प्रोग्राम स्टेप्स का एक सीक्वेंस है
लेकिन हम सिर्फ स्टेप्स को शुरू से अंत तक एक्सेक्यूट नहीं कर सकते हैं
कभी कभी यही काम हमें बार बार करना पड़ता है
उदाहरण के लिए, हमें एक से एम तक हर संभव फैक्टर्स की जांच करनी होगी, अगर यह एम को डिवाइड करता है, फिर इसे लिस्ट में डाल देते है
तो, कुछ स्टेप्स दोहराए जाते हैं
हम उदाहरण के लिए कुछ करते हैं, यहां एक लिस्ट में प्रत्येक आइटम के लिए
कुछ स्टेप्स को तभी एक्सेक्यूट किया जाता है, जब हम जिस वैल्यू को देख रहे हैं, वह एक विशेष कंडीशन को पूरा करता है
इसलिए, जब हम कुछ ऐसा कहते हैं, जैसे कि एम परसेंट आई शून्य है
यदि आई द्वारा एम डिवीज़न पर रिमाइंडर शून्य है, तो अपेण्ड
तो, स्टेप अपेण्ड आई तो एफ एम तभी होता है, जब आई इस शर्त से मेल खाता है, कि यह एम का फैक्टर है
इसलिए, हमने बार बार ऐसे स्टेप्स उठाए हैं, जहां एक ही काम बार बार होता है
और हमारे पास कंडीशनल स्टेप्स हैं, जो किसी विशेष कंडीशन के होने पर ही किया जाता है
तो, हम यहीं रुकेंगे, इस उदाहरण को आपको देखना चाहिए कि प्रोग्राम हम जो जानते हैं, उससे बहुत अलग नहीं हैं
यह केवल उन्हें सही ढंग से लिखने का सवाल है
और यह सुनिश्चित करना कि हम उन सभी इंटरमीडिएट वैल्यूज और कदमों पर नज़र रखें जिनकी हमें आवश्यकता है, क्योंकि हम चीजों को खो सकते हैं
हम इस उदाहरण को और विस्तार से देखेंगे, और इसे लिखने के अन्य तरीके खोजने की कोशिश करेंगे
और अन्य सुविधाओं की जांच करेंगे, लेकिन अनिवार्य रूप से यह प्रोग्रामिंग को चित्रित करने का एक अच्छा तरीका है
