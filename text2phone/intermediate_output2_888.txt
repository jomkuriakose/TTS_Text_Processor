test_888_0001-01 पाइथन में प्रोग्रामिंग
test_888_0001-02 डेटा स्ट्रक्चर्स और एल्गोरिदम पर पाठ्यक्रम पर पहले व्याख्यान में
test_888_0001-03 आपका स्वागत है
test_888_0002-01 आइए हम एक एल्गोरिथ्म और प्रोग्रामिंग क्या है
test_888_0002-02 की मूल परिभाषा के साथ शुरू करते हैं
test_888_0003-01 जैसा कि आप में से अधिकांश शायद जानते हैं
test_888_0003-02 कि एक अल्गोरिथम एक विवरण है
test_888_0003-03 कि कैसे व्यवस्थित रूप से कुछ टास्क करना है
test_888_0004-01 तो
test_888_0004-02 एक अल्गोरिथम में स्टेप्स का एक सीक्वेंस होता है
test_888_0005-01 जिसे हम कुछ हासिल करने के लिए एक रेसिपी के रूप में सोच सकते हैं
test_888_0006-01 तो
test_888_0006-02 पाठ्यक्रम का शब्द रेसिपी खाना पकाने से आता है
test_888_0007-01 जहां हमारे पास लिस्ट ऑफ़ इंग्रेडिएंट्स है
test_888_0007-02 और फिर एक डिश तैयार करने के लिए स्टेप्स का एक सीक्वेंस है
test_888_0008-01 तो
test_888_0008-02 उसी तरह एक अल्गोरिथम कुछ तैयार करने
test_888_0008-03 या दिए गए टास्क को प्राप्त करने का एक तरीका है
test_888_0009-01 इसलिए
test_888_0009-02 हमारी बात के संदर्भ में
test_888_0009-03 एक रेसिपी जिसे हम एक प्रोग्राम कहते हैं
test_888_0010-01 और हम एक प्रोग्रामिंग लैंग्वेज का उपयोग करके
test_888_0010-02 एक प्रोग्राम लिखते हैं
test_888_0011-01 तो
test_888_0011-02 एक प्रोग्रामिंग लैंग्वेज का लक्ष्य
test_888_0011-03 आवश्यक स्टेप्स के सीक्वेंस का वर्णन करने में सक्षम होना है
test_888_0012-01 और यह भी वर्णन करने के लिए
test_888_0012-02 कि अगर बीच में अलग अलग चीजें होती हैं
test_888_0012-03 तो हम स्टेप्स के विभिन्न दृश्यों को कैसे आगे बढ़ा सकते हैं
test_888_0013-01 तो
test_888_0013-02 एक स्टेप की धारणा कुछ ऐसी है
test_888_0013-03 जो एल्गोरिथ्म को एक्सेक्यूट करने वाले द्वारा की जा सकती है
test_888_0014-01 अब
test_888_0014-02 एक प्रोग्राम को सिर्फ मशीन द्वारा एक्सेक्यूट नहीं किया जाना चाहिए
test_888_0015-01 हालांकि यह कंप्यूटर प्रोग्रामिंग का विशिष्ट संदर्भ होगा
test_888_0015-02 जहां हम एक कंप्यूटर से
test_888_0015-03 अपने स्टेप्स को एक्सेक्यूट करने की उम्मीद करते हैं
test_888_0016-01 एक प्रोग्राम को एक व्यक्ति द्वारा एक्सेक्यूट भी किया जा सकता है
test_888_0017-01 उदाहरण के लिए
test_888_0017-02 हाथ में काम
test_888_0017-03 एक समारोह के लिए एक हॉल तैयार करना है
test_888_0018-01 तो
test_888_0018-02 इसमें कमरे की सफाई जैसे विभिन्न स्टेप्स शामिल होंगे
test_888_0019-01 मंच तैयार करना
test_888_0019-02 यह सुनिश्चित करना कि सजावट सही है
test_888_0020-01 कुर्सियों की व्यवस्था करना
test_888_0020-02 और इसी तरह
test_888_0021-01 इसे लोगों की एक टीम द्वारा एक्सेक्यूट किया जाएगा
test_888_0022-01 अब
test_888_0022-02 विशेषज्ञता और लोगों के इस समूह के अनुभव के आधार पर
test_888_0023-01 आप विस्तार के विभिन्न स्तरों पर
test_888_0023-02 इस अल्गोरिथम का वर्णन कर सकते हैं
test_888_0024-01 उदाहरण के लिए
test_888_0024-02 कुर्सियों की व्यवस्था जैसे निर्देश से यह समझ में आएगा
test_888_0024-03 कि इसमें शामिल लोग जानते हैं
test_888_0024-04 कि वास्तव में क्या उम्मीद है
test_888_0025-01 दूसरी ओर
test_888_0025-02 यह उन लोगों का एक नया समूह है
test_888_0025-03 जिन्होंने पहले कभी ऐसा नहीं किया
test_888_0026-01 आपको इस स्टेप्स का अधिक विस्तार से वर्णन करने की आवश्यकता हो सकती है
test_888_0027-01 उदाहरण के लिए
test_888_0027-02 आप यह कहना चाह सकते हैं
test_888_0027-03 कि कुर्सियों को आठ पंक्तियों में व्यवस्थित करें
test_888_0027-04 और प्रत्येक पंक्ति में दस कुर्सियाँ डालें
test_888_0028-01 तो
test_888_0028-02 एक स्टेप की धारणा सब्जेक्टिव है
test_888_0029-01 यह इस बात पर निर्भर करता है
test_888_0029-02 कि हम उस व्यक्ति या मशीन की क्या उम्मीद करते हैं
test_888_0029-03 जो अल्गोरिथम को एक्सेक्यूट कर रहा है
test_888_0030-01 और उस क्षमता के संदर्भ में हम एल्गोरिथ्म का वर्णन करते हैं
test_888_0031-01 इस पाठ्यक्रम में हमारा ध्यान कंप्यूटर एल्गोरिदम पर जा रहा है
test_888_0032-01 और आमतौर पर
test_888_0032-02 ये अल्गोरिथ्म्स इनफार्मेशन मनिप्युलेट करते हैं
test_888_0033-01 सबसे बेसिक प्रकार का अल्गोरिथम
test_888_0033-02 जो हम सभी हाई स्कूल से परिचित हैं
test_888_0033-03 एक अल्गोरिथम है
test_888_0033-04 जो न्यूमेरिकल फंक्शन्स कंप्यूट करता है
test_888_0034-01 उदाहरण के लिए
test_888_0034-02 हमारे पास एक अल्गोरिथम हो सकता है
test_888_0034-03 जो दो नंबर्स
test_888_0034-04 एक्स एंड वाई लेता है
test_888_0035-01 और एक्स की पावर वाई को कंप्यूट करता है
test_888_0036-01 इसलिए
test_888_0036-02 हमने स्कूल में ऐसे कई फंक्शन्स देखे हैं
test_888_0037-01 उदाहरण के लिए
test_888_0037-02 एक्स के स्क्वायर रुट की कम्प्यूटेशन करने के लिए
test_888_0037-03 तो हम स्कूल में क्या करते हैं
test_888_0038-01 क्या हमारे पास
test_888_0038-02 एक्स के स्क्वायर रुट की कम्प्यूटेशन करने का एक जटिल तरीका है
test_888_0039-01 या एक्स डिवाइडेड बाई वाई हो सकते हैं
test_888_0039-02 जहां हम इस लॉन्ग डिवीज़न पर करते हैं
test_888_0039-03 है ना
test_888_0040-01 तो
test_888_0040-02 ये सभी अल्गोरिथ्म्स हैं
test_888_0040-03 जो एक या अधिक नंबर्स में दिए गए वैल्यूज कंप्यूट करते हैं
test_888_0040-04 जो वे इस कार्य के आउटपुट कंप्यूट करते हैं
test_888_0041-01 लेकिन
test_888_0041-02 हम सभी जिन्होंने कम्प्यूटर्स का उपयोग किया है
test_888_0041-03 वे जानते हैं
test_888_0041-04 कि कई अन्य चीजें भी कम्प्यूटेशन के दायरे में आती हैं
test_888_0042-01 उदाहरण के लिए
test_888_0042-02 यदि हम जानकारी की व्यवस्था करने के लिए एक स्प्रेड शीट का उपयोग करते हैं
test_888_0043-01 और फिर हम एक कॉलम सॉर्टेड चाहते हैं
test_888_0044-01 इसलिए
test_888_0044-02 इसमें किसी क्रम में कॉलम में
test_888_0044-03 आइटम्स को पुनर्व्यवस्थित करना शामिल है
test_888_0045-01 या तो असेंडिंग आर्डर में
test_888_0045-02 या डेस्केन्डिंग आर्डर में
test_888_0046-01 तो
test_888_0046-02 इनफार्मेशन को पुनर्गठित करना भी एक कम्प्यूटेशनल टास्क है
test_888_0047-01 और हमें यह जानने की जरूरत है
test_888_0047-02 कि यह कैसे किया जाए
test_888_0048-01 हम अपने जीवन में
test_888_0048-02 हमारे आसपास की कंप्यूटेशन्स भी देखते हैं
test_888_0049-01 उदाहरण के लिए
test_888_0049-02 जब हम एक यात्रा बुकिंग साइट पर जाते हैं
test_888_0050-01 और हम एक शहर से दूसरे शहर की उड़ान बुक करने की कोशिश करते हैं
test_888_0051-01 यह मिनिमम टाइम या मिनिमम कॉस्ट के संदर्भ में
test_888_0051-02 उड़ानों की व्यवस्था करने की पेशकश करेगा
test_888_0052-01 तो
test_888_0052-02 ये ऑप्टिमाइजेशन प्रोब्लेम्स हैं
test_888_0053-01 इसमें किसी विशेष तरीके से जानकारी की व्यवस्था करना भी शामिल है
test_888_0054-01 और फिर कुछ क्वांटिटी कंप्यूट करना
test_888_0054-02 जो हम चाहते हैं
test_888_0055-01 इस मामले में हम जानना चाहते हैं
test_888_0055-02 कि हम ए से बी
test_888_0056-01 सभी अलग अलग तरीकों से
test_888_0056-02 हम ए से बी तक प्राप्त कर सकते हैं
test_888_0056-03 हम इनमे से ऑप्टिमम चाहते हैं
test_888_0057-01 और निश्चित रूप से
test_888_0057-02 बहुत बहुत अधिक चीजें हैं
test_888_0057-03 जिन्हें हम दिन प्रतिदिन देखते हैं
test_888_0057-04 जिन्हें कम्प्यूटर्स प्रोग्राम द्वारा एक्सेक्यूट किया जाता है
test_888_0058-01 हम उदाहरण के लिए गेम्स खेल सकते हैं
test_888_0059-01 हम सुडोकु को हल कर सकते हैं
test_888_0059-02 या हम एक प्रोग्राम के खिलाफ चैस खेल सकते हैं
test_888_0060-01 जब हम डॉक्यूमेंट टाइप करने के लिए
test_888_0060-02 वर्ड प्रोसेसर का उपयोग करते हैं
test_888_0061-01 या यहां तक कि
test_888_0061-02 जब हम अपने सेल फोन का उपयोग
test_888_0061-03 एसएमएस संदेशों को टाइप करने के लिए करते हैं
test_888_0062-01 कम्प्यूटर्स हमारी वर्तनी में सुधार का सुझाव देता है
test_888_0063-01 तो
test_888_0063-02 हम इस पाठ्यक्रम में इनमें से कुछ बातों को देखेंगे
test_888_0064-01 लेकिन बात यह है
test_888_0064-02 कि हमारे संदर्भ में एक प्रोग्राम कुछ भी है
test_888_0064-03 जो जानकारी को देखता है
test_888_0065-01 और इसे किसी दिए गए आवश्यकता में मैनिपुलेट करता है
test_888_0066-01 इसलिए यह न केवल एक नंबर लेने
test_888_0066-02 और एक नंबर आउट रखने का सवाल है
test_888_0067-01 इसमें चीजों को पुनर्व्यवस्थित करना शामिल हो सकता है
test_888_0067-02 यह कंप्यूटिंग को अधिक जटिल चीजों को शामिल कर सकता है
test_888_0068-01 इसमें सूचनाओं को एक विशेष तरीके से व्यवस्थित करना शामिल हो सकता है
test_888_0068-02 ताकि ये कंप्यूटेशन्स अधिक ट्रैक्टेबल हो सकें
test_888_0069-01 और जिसे हम डेटा स्ट्रक्चर कहते हैं
test_888_0070-01 इसलिए
test_888_0070-02 इसका वर्णन करने के लिए
test_888_0070-03 हम एक फंक्शन को देखते हैं
test_888_0070-04 जिसे हम में से अधिकांश ने देखा है
test_888_0071-01 और इसे एल्गोरिद्मिक रूप से समझने की कोशिश करें
test_888_0072-01 तो
test_888_0072-02 जिस संपत्ति की मैं कम्प्यूटेशन करना चाहता हूं
test_888_0072-03 वह दो पॉजिटिव इंतेजरस एम और एन का ग्रेटेस्ट कॉमन डिवाइज़र है
test_888_0073-01 इसलिए
test_888_0073-02 जैसा कि हम जानते हैं
test_888_0073-03 कि एक डिवाइज़र एक नंबर है
test_888_0073-04 जो डिवाइड करती है
test_888_0074-01 इसलिए
test_888_0074-02 के एम का एक डिवाइज़र है
test_888_0074-03 अगर मैं एम को के द्वारा डिवाइड कर सकता हूं
test_888_0074-04 और कोई शेष नहीं पा सकता हूं
test_888_0075-01 तो
test_888_0075-02 एम और एन का ग्रेटेस्ट कॉमन डिवाइज़र
test_888_0075-03 कुछ ऐसा होना चाहिए
test_888_0075-04 जो एक कॉमन डिवाइज़र हो
test_888_0076-01 तो
test_888_0076-02 कॉमन का मतलब है
test_888_0076-03 कि यह दोनों को डिवाइड करना चाहिए
test_888_0077-01 और यह इनमें से सबसे बड़ा होना चाहिए
test_888_0078-01 तो
test_888_0078-02 यह सबसे बड़ा के है
test_888_0078-03 जो एम को डिवाइड करता है
test_888_0078-04 और के दिवाइड्स एन है
test_888_0079-01 उदाहरण के लिए
test_888_0079-02 यदि हम नंबर्स आठ और बारह को देखते हैं
test_888_0080-01 फिर हम देख सकते हैं
test_888_0080-02 कि चार आठ का फैक्टर है
test_888_0081-01 चार आठ का डिवाइज़र है
test_888_0081-02 चार बारह का भी डिवाइज़र है
test_888_0082-01 बारह का एक और डिवाइज़र छह है
test_888_0082-02 लेकिन छह आठ का डिवाइज़र नहीं है
test_888_0083-01 तो
test_888_0083-02 अगर हम आठ और बारह के डिवाइज़र्स से गुजरते हैं
test_888_0084-01 यह देखना आसान है
test_888_0084-02 कि सबसे बड़ी नंबर
test_888_0084-03 जो आठ और बारह दोनों को डिवाइड करती है
test_888_0084-04 चार है
test_888_0085-01 तो
test_888_0085-02 आठ और बारह का जीसीडी चार है
test_888_0086-01 अठारह और पच्चीस का क्या है
test_888_0087-01 पच्चीस पांच से पांच है
test_888_0087-02 तो इसमें एक और पच्चीस के अलावा
test_888_0087-03 केवल एक ही डिवाइज़र है
test_888_0087-04 जो पाँच है
test_888_0087-05 और पाँच अठारह का डिवाइज़र नहीं है
test_888_0088-01 लेकिन
test_888_0088-02 सौभाग्य से एक अठारह का एक डिवाइज़र है
test_888_0089-01 तो
test_888_0089-02 हम कह सकते हैं
test_888_0089-03 कि अठारह और पच्चीस का जीसीडी एक है
test_888_0090-01 एक से बड़ा कोई नंबर नहीं है
test_888_0090-02 जो अठारह और पच्चीस दोनों को डिवाइड करता है
test_888_0091-01 चूंकि
test_888_0091-02 हर नंबर को हम अठारह और पच्चीस के मामले में देखते हैं
test_888_0092-01 दो नंबरों में हमेशा कम से कम एक कॉमन डिवाइज़र रहेगा
test_888_0093-01 तो
test_888_0093-02 जीसीडी हमेशा अच्छी तरह से डिफ़ाइन किया जाएगा
test_888_0093-03 यह कभी नहीं होगा
test_888_0093-04 कि हम एक कॉमन डिवाइज़र नहीं पा सकते हैं
test_888_0094-01 और क्योंकि सभी कॉमन डिवाइज़र नंबर्स हो सकते हैं
test_888_0094-02 हम उन्हें सबसे छोटे से सबसे बड़े की व्यवस्था कर सकते हैं
test_888_0095-01 और सबसे बड़ा ग्रेटेस्ट कॉमन डिवाइज़र के रूप में चुनें
test_888_0096-01 तो
test_888_0096-02 पॉजिटिव नंबर्स एम और एन की
test_888_0096-03 किसी भी जोड़ी को देखते हुए
test_888_0097-01 हम निश्चित रूप से
test_888_0097-02 इन दो नंबरों के जीसीडी की कम्प्यूटेशन कर सकते हैं
test_888_0098-01 तो
test_888_0098-02 एम और एन के जीसीडी की कंप्यूटिंग के बारे में
test_888_0098-03 कोई कैसे जाएगा
test_888_0099-01 तो
test_888_0099-02 यह वह जगह है
test_888_0099-03 जहां हम अल्गोरिथ्मिक बिट में आते हैं
test_888_0100-01 हम किसी भी एम और किसी भी एन के लिए
test_888_0100-02 व्यवस्थित रूप से
test_888_0100-03 कंप्यूटिंग जीसीडी के यूनिफार्म तरीके का वर्णन करना चाहते हैं
test_888_0101-01 तो यहाँ एक बहुत ही सरल प्रक्रिया है
test_888_0101-02 यह सबसे कुशल नहीं है
test_888_0101-03 क्योंकि हम आगे जाके बेहतर देखेंगे
test_888_0102-01 लेकिन
test_888_0102-02 अगर हम सिर्फ जीसीडी की परिभाषा को देखें
test_888_0102-03 तो यह कहता है
test_888_0102-04 कि एम के सभी फैक्टर्स को देखें
test_888_0103-01 एन के सभी फैक्टर्स को देखें
test_888_0103-02 और सबसे बड़ा खोजें
test_888_0103-03 जो दोनों का फैक्टर है
test_888_0104-01 तो ऐसा करने का भोला तरीका
test_888_0104-02 पहले नंबर एम के सभी फैक्टर्स को लिस्ट करना होगा
test_888_0105-01 फिर दूसरे नंबर एन के सभी फैक्टर्स को लिस्ट बद्ध करें
test_888_0106-01 और फिर इन दोनों लिस्ट्स में सबसे बड़ी नंबर्स है
test_888_0106-02 जो दोनों लिस्ट्स में दिखाई देती है
test_888_0107-01 यह लगभग सचमुच जीसीडी की डेफिनिशन है
test_888_0108-01 अब
test_888_0108-02 सवाल यह है
test_888_0108-03 कि क्या यह एक एल्गोरिथ्म है
test_888_0109-01 ठीक है
test_888_0109-02 विस्तार के एक उच्च स्तर पर
test_888_0109-03 अगर हम लिस्ट के फैक्टर्स को
test_888_0109-04 एक ही स्टेप के रूप में सोचते हैं
test_888_0110-01 हम एक एल्गोरिथ्म से क्या चाहते हैं
test_888_0110-02 दो चीजें हैं
test_888_0111-01 एक यह है
test_888_0111-02 कि क्या करना है
test_888_0111-03 का विवरण एक फाइनाइट तरीके से लिखा जाना चाहिए
test_888_0112-01 इस अर्थ में
test_888_0112-02 कि मैं एम और एन के वैल्यूज की परवाह किए बिना
test_888_0112-03 इन इंस्ट्रक्शंस को इस तरह लिख सकूं
test_888_0112-04 कि आप इसे पढ़ सकें
test_888_0112-05 और सभी के लिए समझ सकें
test_888_0113-01 तो
test_888_0113-02 यहाँ बहुत स्पष्ट है
test_888_0113-03 कि हमारे पास ठीक तीन स्टेप्स हैं
test_888_0114-01 इसलिए
test_888_0114-02 हमारे पास तीन स्टेप्स हैं
test_888_0114-03 जो अल्गोरिथम का गठन करते हैं
test_888_0115-01 तो
test_888_0115-02 यह निश्चित रूप से
test_888_0115-03 एक फाइनाइट तरीके से प्रस्तुत किया गया है
test_888_0116-01 एक अल्गोरिथम की अन्य आवश्यकता यह है
test_888_0116-02 कि हमें फाइनाइट स्टेप्स के बाद जवाब मिलना चाहिए
test_888_0117-01 अब
test_888_0117-02 कदमों की यह फाइनाइट संख्या
test_888_0117-03 एम और एन के विभिन्न वैल्यूज के लिए अलग हो सकता है
test_888_0118-01 आप कल्पना कर सकते हैं
test_888_0118-02 कि यदि आपके पास एम के लिए बहुत छोटा नंबर है
test_888_0118-03 तो कई फैक्टर नहीं हैं
test_888_0119-01 यदि आपके पास एम के लिए बहुत बड़ी नंबर है
test_888_0119-02 तो आपके पास कई फैक्टर्स हो सकते हैं
test_888_0120-01 तो
test_888_0120-02 एम और एन के फैक्टर्स को सूचीबद्ध करने की प्रक्रिया में
test_888_0120-03 लंबा समय लग सकता है
test_888_0121-01 हालांकि हम गारंटी देना चाहते हैं
test_888_0121-02 कि यह प्रक्रिया हमेशा समाप्त हो जाएगी
test_888_0122-01 और फिर ऐसा करके
test_888_0123-01 हम हमेशा सबसे बड़ा नंबर खोजने में सक्षम होंगे
test_888_0123-02 जो दोनों लिस्ट्स में दिखाई देती है
test_888_0124-01 इसलिए
test_888_0124-02 यह तर्क देने के लिए
test_888_0124-03 कि यह प्रक्रिया अच्छी तरह से परिभाषित है
test_888_0125-01 हमें केवल यह महसूस करने की आवश्यकता है
test_888_0125-02 कि एम के कारक
test_888_0125-03 एक और एम के बीच होने चाहिए
test_888_0126-01 दूसरे शब्दों में
test_888_0126-02 हालांकि असीम रूप से कई अलग अलग संभावनाएं हैं
test_888_0126-03 क्योंकि हम जो फैक्टर करते हैं
test_888_0126-04 उन्हें एम से बड़ी किसी भी नंबर्स को नहीं देखना होगा
test_888_0127-01 तो
test_888_0127-02 हम को एम के फैक्टर्स कंप्यूट करने के लिए
test_888_0128-01 एक से एम तक हर नंबर का परीक्षण करना होगा
test_888_0129-01 और अगर यह एम को एक रिमाइंडर के बिना डिवाइड करता है
test_888_0129-02 तो हम इसे फैक्टर्स की लिस्ट में जोड़ते हैं
test_888_0130-01 इसलिए
test_888_0130-02 हम फैक्टर्स की एक एम्प्टी लिस्ट के साथ शुरू करते हैं
test_888_0131-01 और हम एम तक
test_888_0131-02 एक
test_888_0131-03 दो
test_888_0131-04 तीन
test_888_0131-05 चार बारी से विचार करते हैं
test_888_0132-01 और ऐसी प्रत्येक नंबर के लिए हम जाँच करते हैं
test_888_0132-02 कि क्या हम इस नंबर से एम को डिवाइड करते हैं
test_888_0132-03 तो हमें शून्य का रिमाइंडर मिलता है
test_888_0133-01 हमें रिमाइंडर शून्य मिलता है
test_888_0133-02 जिसे हम लिस्ट में जोड़ते हैं
test_888_0134-01 तो
test_888_0134-02 आइए एक ठोस उदाहरण देखें
test_888_0134-03 आइए हम चौदह और तिरसठ के जीसीडी की कम्प्यूटेशन करने का प्रयास करें
test_888_0135-01 तो
test_888_0135-02 हमारे अल्गोरिथम में पहला स्टेप
test_888_0135-03 चौदह के फैक्टर्स की कम्प्यूटेशन करने के लिए कहता है
test_888_0136-01 तो
test_888_0136-02 चौदह के फैक्टर्स के ऊपर
test_888_0136-03 हमारे अवलोकन से
test_888_0136-04 एक और चौदह के बीच होना चाहिए
test_888_0136-05 चौदह से बड़ा कुछ भी फैक्टर नहीं हो सकता है
test_888_0137-01 इसलिए हम एक और चौदह के बीच
test_888_0137-02 सभी संभावित फैक्टर्स को सूचीबद्ध करके
test_888_0137-03 और उनका परीक्षण करके शुरू करते हैं
test_888_0138-01 इसलिए
test_888_0138-02 हम निश्चित रूप से जानते हैं
test_888_0138-03 कि एक हमेशा डिवाइज़र होगा
test_888_0139-01 इस मामले में
test_888_0139-02 दो से चौदह डिवाइड होते हैं
test_888_0139-03 क्योंकि दो से चौदह डिवाइड पर सात होते हैं
test_888_0139-04 और कोई रिमाइंडर नहीं हैं
test_888_0140-01 अब
test_888_0140-02 तीन डिवाइड नहीं करता है
test_888_0141-01 चार डिवाइड नहीं करता है
test_888_0142-01 पांच डिवाइड नहीं करता
test_888_0142-02 छह डिवाइड नहीं करता
test_888_0143-01 लेकिन सात करता है
test_888_0143-02 क्योंकि अगर हम चौदह को सात से डिवाइड करते हैं
test_888_0144-01 हमें रिमाइंडर शून्य मिलता है
test_888_0145-01 फिर आठ डिवाइड नहीं करता
test_888_0146-01 नौ डिवाइड नहीं करता है
test_888_0146-02 और इसी तरह
test_888_0147-01 और अंत में
test_888_0147-02 हम पाते हैं
test_888_0147-03 कि केवल अन्य फैक्टर बचा है
test_888_0147-04 चौदह ही
test_888_0148-01 सही है
test_888_0148-02 इसलिए
test_888_0148-03 हर नंबर एम के
test_888_0148-04 वन एंड एम फैक्टर्स होंगे
test_888_0148-05 और फिर बीच में फैक्टर्स हो सकते हैं
test_888_0149-01 इसलिए
test_888_0149-02 ऐसा करने के बाद
test_888_0149-03 हमने अब चौदह के फैक्टर्स की पहचान की है
test_888_0150-01 और ये फैक्टर्स ठीक एक
test_888_0150-02 दो
test_888_0150-03 सात
test_888_0150-04 और चौदह हैं
test_888_0151-01 तो
test_888_0151-02 चौदह और तिरसठ के जीसीडी की कम्प्यूटेशन में अगला स्टेप
test_888_0151-03 तिरसठ के फैक्टर्स की कम्प्यूटेशन करना है
test_888_0152-01 तो
test_888_0152-02 उसी तरह हम एक से तिरसठ तक सारे नम्बर लिख देते हैं
test_888_0153-01 और हम जाँच करते हैं
test_888_0153-02 कि कौन से डिवाइज़र्स हैं
test_888_0153-03 तो फिर से हम पाएंगे कि एक डिवाइड करता है
test_888_0154-01 यहां
test_888_0154-02 दो डिवाइड नहीं करता
test_888_0154-03 क्योंकि तिरसठ भी नहीं होता
test_888_0154-04 तीन डिवाइड करता है
test_888_0155-01 फिर हमें यहां संख्याओं का एक गुच्छा मिलेगा
test_888_0155-02 जो कि डिवाइड नहीं करता है
test_888_0156-01 और फिर हम पाएंगे कि सात डिवाइज़र हैं
test_888_0156-02 क्योंकि सात नाइन तिरसठ हैं
test_888_0157-01 फिर आठ डिवाइड नहीं करता
test_888_0158-01 लेकिन नौ करता है
test_888_0159-01 फिर से संख्याओं का एक बड़ा अंतर होता है
test_888_0159-02 जो कि डिवाइड नहीं करता है
test_888_0160-01 और फिर इक्कीस डिवाइड करता है
test_888_0160-02 क्योंकि इक्कीस तीन तिरसठ है
test_888_0161-01 और फिर अंत में हम पाते हैं
test_888_0161-02 कि हमारे पास अंतिम फैक्टर तिरसठ है
test_888_0162-01 इसलिए
test_888_0162-02 यदि हम प्रत्येक नंबर को पार करने के लिए
test_888_0162-03 एक से तिरसठ तक व्यवस्थित रूप से इस से गुजरते हैं
test_888_0162-04 जो फैक्टर्स नहीं है
test_888_0163-01 हम लिस्ट में एक
test_888_0163-02 तीन
test_888_0163-03 सात
test_888_0163-04 नौ
test_888_0163-05 इक्कीस और तिरसठ के साथ समाप्त करते हैं
test_888_0164-01 दो नंबर
test_888_0164-02 चौदह और तिरसठ के फैक्टर्स कंप्यूट करके
test_888_0165-01 हमारे अल्गोरिथम में अगला स्टेप कहता है
test_888_0165-02 कि हमें सबसे बड़ा फैक्टर खोजना चाहिए
test_888_0165-03 जो दोनों लिस्ट में दिखाई देता है
test_888_0166-01 तो
test_888_0166-02 हम ऐसा कैसे करते हैं
test_888_0167-01 हम सामान्य फैक्टर्स की लिस्ट कैसे बनाते हैं
test_888_0168-01 अब ऐसा करने के लिए
test_888_0168-02 और अधिक चतुर तरीके हैं
test_888_0168-03 लेकिन यहां एक बहुत ही सरल तरीका है
test_888_0169-01 हम सिर्फ एक लिस्ट से गुजरते हैं
test_888_0169-02 जो चौदह के फैक्टर्स की लिस्ट कहता है
test_888_0170-01 और लिस्ट में प्रत्येक आइटम के लिए हम जांच करते हैं
test_888_0170-02 कि क्या यह तिरसठ का फैक्टर है
test_888_0171-01 इसलिए
test_888_0171-02 हम एक के साथ शुरू करते हैं
test_888_0171-03 और हम कहते हैं
test_888_0171-04 कि एक तिरसठ के फैक्टर के रूप में दिखाई देता है
test_888_0172-01 यह करता है
test_888_0172-02 इसलिए हम इसे कॉमन फैक्टर्स की लिस्ट में जोड़ते हैं
test_888_0173-01 फिर हम दो को देखते हैं
test_888_0173-02 और फिर हम पूछते हैं
test_888_0173-03 कि क्या ऐसा प्रतीत होता है
test_888_0173-04 कि यह दिखाई नहीं देता है
test_888_0173-05 इसलिए हम इसे छोड़ देते हैं
test_888_0174-01 फिर हम तीन को देखते हैं
test_888_0175-01 सात को देखें और हम पाते हैं
test_888_0175-02 कि सात दिखाई देते हैं
test_888_0176-01 तो
test_888_0176-02 हम सात जोड़ते हैं
test_888_0176-03 फिर अंत में हम चौदह को देखते हैं
test_888_0177-01 और पाते हैं
test_888_0177-02 कि चौदह दिखाई नहीं देता है
test_888_0177-03 इसलिए हम इसे छोड़ देते हैं
test_888_0178-01 तो इस तरह
test_888_0178-02 हम व्यवस्थित रूप से एक से गुजरे हैं
test_888_0179-01 दो
test_888_0180-01 सात और चौदह
test_888_0181-01 और निष्कर्ष निकाला कि इनमें से केवल एक और सात
test_888_0181-02 दोनों लिस्ट्स में दिखाई देते हैं
test_888_0182-01 और अब ऐसा करने के बाद
test_888_0182-02 हमारे पास सभी कॉमन फैक्टर की लिस्ट है
test_888_0183-01 हमने उनकी कम्प्यूटेशन सबसे छोटे से बड़े तक की
test_888_0183-02 क्योंकि हम असेंडिंग आर्डर चौदह के फैक्टर्स से गुज़रे
test_888_0184-01 तो
test_888_0184-02 यह लिस्ट असेंडिंग आर्डर में भी होगी
test_888_0185-01 इसलिए
test_888_0185-02 सबसे बड़ा फैक्टर लौटाना
test_888_0185-03 सिर्फ सात की इस लिस्ट में
test_888_0185-04 सबसे राइटमोस्ट फैक्टर है
test_888_0186-01 तो
test_888_0186-02 यह हमारे कार्य का आउटपुट है
test_888_0186-03 तो
test_888_0186-04 हमने चौदह के फैक्टर्स की कम्प्यूटेशन की है
test_888_0186-05 तिरसठ के फैक्टर्स की कम्प्यूटेशन की है
test_888_0187-01 चौदह के हर फैक्टर्स के लिए व्यवस्थित रूप से जाँच की
test_888_0187-02 कि क्या यह भी तिरसठ का फैक्टर है
test_888_0188-01 और इस लिस्ट से
test_888_0188-02 कॉमन फैक्टर की इस लिस्ट की कम्प्यूटेशन की
test_888_0189-01 हमने सबसे बड़ा एक निकाला है
test_888_0189-02 और यह वास्तव में हमारा जीसीडी है
test_888_0190-01 तो
test_888_0190-02 यह एक उदाहरण है
test_888_0190-03 कि यह अल्गोरिथम कैसे एक्सेक्यूट करेगा
test_888_0191-01 इसलिए यदि आपको इसे थोड़ा और विस्तार से लिखना था
test_888_0192-01 तब हम कह सकते थे
test_888_0193-01 हमें यह ध्यान देने की आवश्यकता है
test_888_0193-02 कि हमें इन लिस्ट्स को याद रखने की आवश्यकता है
test_888_0194-01 और फिर उनके पास वापस आओ
test_888_0194-02 इसलिए हमें चौदह के फैक्टर्स कंप्यूट करने की आवश्यकता है
test_888_0194-03 जो हमें इसे कहीं लिखने की आवश्यकता है
test_888_0195-01 हमें तिरसठ के फैक्टर्स कम्प्यूट करने की आवश्यकता है
test_888_0195-02 इसे कहीं लिखें और फिर इन दोनों लिस्ट्स की तुलना करें
test_888_0196-01 इसलिए
test_888_0196-02 दूसरे शब्दों में हमें इन्हें स्टोर करने के लिए
test_888_0196-03 कुछ नेम्स असाइन करने की आवश्यकता है
test_888_0197-01 तो आइए इन लिस्ट्स के नेम्स के रूप में
test_888_0197-02 एन के फैक्टर्स के एफ एन एम के फैक्टर्स के लिए
test_888_0197-03 एफ एम को कॉल करें
test_888_0198-01 तो
test_888_0198-02 हम क्या करते हैं
test_888_0198-03 कि हम नंबर्स एक से एम तक चलते हैं
test_888_0199-01 और इस लिस्ट
test_888_0199-02 एक से एम मैं प्रत्येक आई के लिए
test_888_0200-01 हम जांच करते हैं
test_888_0200-02 कि क्या आई एम को डिवाइड करता है
test_888_0201-01 क्या आई द्वारा एम डिवाइडेड शून्य रिमाइंडर है
test_888_0201-02 और अगर ऐसा है
test_888_0201-03 तो हमने एफ एम की लिस्ट फैक्टर्स में जोड़ा
test_888_0202-01 इसी तरह
test_888_0202-02 एक से एन तक प्रत्येक जे के लिए
test_888_0203-01 हम जाँच करते हैं
test_888_0203-02 कि क्या जे एन को डिवाइड करता है
test_888_0203-03 और यदि हां
test_888_0203-04 तो हम इसे लिस्ट एफ एन में जोड़ते हैं
test_888_0204-01 अब हमारे पास दो लिस्ट्स एफ एम एंड एफ एन हैं
test_888_0204-02 जो एम और एन के फैक्टर्स हैं
test_888_0205-01 अब
test_888_0205-02 हम कॉमन फैक्टर्स की लिस्ट कंप्यूट करना चाहते हैं
test_888_0205-03 जिन्हें हम सी एफ कहेंगे
test_888_0206-01 तो
test_888_0206-02 हम जो करते हैं
test_888_0206-03 वह हर एफ के लिए है
test_888_0206-04 जो पहले नंबर का फैक्टर है
test_888_0207-01 हमारे मामले में याद रखें यह चौदह था
test_888_0208-01 प्रत्येक एफ के लिए
test_888_0208-02 इसलिए हम अपने मामले में एक
test_888_0208-03 दो
test_888_0208-04 सात और चौदह से गुजरे
test_888_0209-01 इसलिए
test_888_0209-02 इस लिस्ट में प्रत्येक एफ के लिए
test_888_0209-03 हम कॉमन फैक्टर्स की लिस्ट में एफ जोड़ते हैं
test_888_0210-01 यदि यह दूसरी लिस्ट में भी दिखाई देता है
test_888_0210-02 तो दूसरी लिस्ट में यदि आपको याद है
test_888_0210-03 कि एक
test_888_0210-04 तीन
test_888_0210-05 सात
test_888_0210-06 नौ
test_888_0210-07 इक्कीस और साठ तीन थे
test_888_0211-01 इसलिए
test_888_0211-02 हम इस लिस्ट के साथ एफ की तुलना करते हैं
test_888_0211-03 और अगर हम इसे पाते हैं
test_888_0211-04 तो हमने इसे सी एफ में जोड़ा
test_888_0212-01 और ऐसा करने के बाद
test_888_0212-02 अब हम कॉमन फैक्टर्स की लिस्ट में सबसे बड़ा वैल्यू वापस करना चाहते हैं
test_888_0213-01 याद रखें कि एक हमेशा एक कॉमन फैक्टर होगा
test_888_0213-02 इसलिए लिस्ट सी एफ खाली नहीं होगा
test_888_0214-01 इसलिए
test_888_0214-02 कम से कम एक वैल्यू होगा
test_888_0214-03 लेकिन चूंकि हम उन्हें असेंडिंग ऑर्डर्स में ऐड किये
test_888_0214-04 क्योंकि लिस्ट एफ एम और एफ एन का निर्माण
test_888_0214-05 एक से एम और एक एन से किया गया था
test_888_0215-01 सबसे बड़ा वैल्यू राइटमोस्ट वैल्यू होगा
test_888_0216-01 तो
test_888_0216-02 यह हमें जीसीडी के लिए थोड़ा और विस्तृत एल्गोरिथ्म देता है
test_888_0217-01 इसके कमोबेश पिछले वाले के समान ही है
test_888_0217-02 सिवाय इसके कि यह थोड़ा और विस्तार से बताता है
test_888_0217-03 कि एम के फैक्टर्स की लिस्ट कंप्यूट कैसे करें
test_888_0218-01 एन के फैक्टर्स की लिस्ट कंप्यूट कैसे करें
test_888_0218-02 और इन दोनों सूचियों के बीच सबसे बड़े सामान्य फैक्टर्स कंप्यूट कैसे करें
test_888_0219-01 इसलिए
test_888_0219-02 पहले हमारे पास तीन स्टेटमेंट्स थे
test_888_0219-03 अब हमने इसे छह से अधिक विस्तृत स्टेटमेंट्स में विस्तारित किया है
test_888_0220-01 तो
test_888_0220-02 यह पहले से ही हमें अपना पहला पाइथन प्रोग्राम लिखने के लिए पर्याप्त जानकारी देता है
test_888_0221-01 बेशक
test_888_0221-02 हमें इसे लिखने से पहले थोड़ा और सीखने की आवश्यकता होगी
test_888_0222-01 लेकिन हम निश्चित रूप से यह पता लगा सकते हैं
test_888_0222-02 कि इसे कैसे पढ़ा जाए
test_888_0223-01 तो यह पाइथन प्रोग्राम क्या कर रहा है
test_888_0223-02 ठीक वही है
test_888_0223-03 जो हमने पिछले स्टेप में अनौपचारिक रूप से वर्णित किया था
test_888_0224-01 तो
test_888_0224-02 पाइथन प्रोग्राम में पहली बात एक पंक्ति है
test_888_0224-03 जो फंक्शन को डिफाइन करती है
test_888_0224-04 तो
test_888_0224-05 हम एम कॉमा एन के एक फंक्शन जीसीडी को परिभाषित कर रहे हैं
test_888_0225-01 तो
test_888_0225-02 एम और एन दो आर्गुमेंट हैं
test_888_0225-03 जो किसी भी फंक्शन की तरह कोई भी नंबर हो सकते हैं
test_888_0225-04 जो जब आप गणित में एफ ऑफ़ एक्स वाई लिखते हैं
test_888_0225-05 तो इसका मतलब है
test_888_0225-06 कि एक्स और वाई मनमाने वैल्यू हैं
test_888_0225-07 और एव्री एक्स एंड वाई उन वैल्यूों के आधार पर कुछ करते हैं
test_888_0225-08 जिन्हें आप फंक्शन के साथ कहते हैं
test_888_0226-01 तो
test_888_0226-02 यह कहता है
test_888_0226-03 कि यह हमारी डेफिनिशन है
test_888_0226-04 इसलिए डेफिनिशन के लिए डेफ
test_888_0227-01 एक फंक्शन जीसीडी एम एन
test_888_0228-01 तो
test_888_0228-02 अब पहला स्टेप एम के फैक्टर्स की लिस्ट कंप्यूट करना है
test_888_0229-01 पाइथन में हम स्क्वायर ब्रैकेट्स का उपयोग करके एक लिस्ट लिखते हैं
test_888_0230-01 तो
test_888_0230-02 लिस्ट एक्स
test_888_0230-03 वाई
test_888_0230-04 जेड और कई पर लिखी गई है
test_888_0231-01 तो
test_888_0231-02 एम्प्टी लिस्ट सिर्फ एक ओपन ब्रैकेट और एक स्क्वायर क्लोज्ड ब्रैकेट है
test_888_0232-01 इसलिए
test_888_0232-02 हम फैक्टर्स की एक एम्प्टी लिस्ट के साथ शुरू करते हैं
test_888_0232-03 ताकि इस इक्वालिटी का मतलब है
test_888_0232-04 एक वैल्यू असाइन करना
test_888_0233-01 तो
test_888_0233-02 हम खाली लिस्ट होने के लिए एम के फैक्टर्स की लिस्ट एफ एम असाइन करते हैं
test_888_0234-01 अब
test_888_0234-02 हमें रेंज वन से एन में
test_888_0234-03 हर वैल्यू का परीक्षण करने की आवश्यकता है
test_888_0235-01 अब
test_888_0235-02 पाइथन के पास रेंज नामक एक बिल्टइन फंक्शन है
test_888_0236-01 हम इसे देखेंगे
test_888_0237-01 पाइथन की ख़ासियत के कारण
test_888_0237-02 यह आपके द्वारा अपेक्षित रेंज नहीं है
test_888_0237-03 बल्कि एक कम है
test_888_0238-01 इसलिए
test_888_0238-02 अगर मैं कहता हूं कि मुझे रेंज वन से एम प्लस वन में नंबर्स दें
test_888_0239-01 यह मुझे रेंज वन टू एम में नंबर्स देता है
test_888_0240-01 एक अपर लिमिट तक
test_888_0240-02 लेकिन अपर लिमिट को शामिल नहीं करता
test_888_0241-01 तो यह कहेगा कि आई वैल्यूज एक
test_888_0241-02 दो
test_888_0241-03 तीन से एम तक ले सकता हैं
test_888_0242-01 आई के इन वैल्यूज में से प्रत्येक के लिए जाँच करें
test_888_0242-02 कि क्या यह ट्रू है
test_888_0243-01 अब परसेंटेज रिमाइंडर ऑपरेशन है
test_888_0244-01 इसलिए
test_888_0244-02 यह जांचता है
test_888_0244-03 कि क्या आई द्वारा एम डिवाइड का रिमाइंडर शून्य है
test_888_0245-01 यदि आई द्वारा एम डिवाइड का रिमाइंडर शून्य है
test_888_0245-02 तो हम आई एक लिस्ट एफ एम में जोड़ देंगे
test_888_0245-03 हम इसे अपेण्ड से करेंगे
test_888_0245-04 यह एक इंग्लिश वर्ड है
test_888_0246-01 जिसका मतलब है
test_888_0246-02 कि लिस्ट के अंत में जोड़ें
test_888_0246-03 इसलिए आई को एन से अपेण्ड करते हैं
test_888_0247-01 इसलिए
test_888_0247-02 इस स्टेप में हमने एफ एम कंप्यूट किया है
test_888_0247-03 यह वही है
test_888_0247-04 जो हमने पिछले उदाहरण में अनौपचारिक रूप से लिखा था
test_888_0248-01 हमने सिर्फ इतना कहा कि एक से एम प्रत्येक आई जोड़ देता हूं
test_888_0248-02 अगर आई एम को डिवाइड करता हैं
test_888_0249-01 और अब हमने इसे पायथन सिंटैक्स में किया है
test_888_0250-01 तो
test_888_0250-02 हमने फैक्टर्स की एक खाली लिस्ट को डिफाइन किया है
test_888_0250-03 और उस रेंज में प्रत्येक नंबर के लिए
test_888_0251-01 हमने जाँच की है
test_888_0251-02 कि क्या यह एक डिवाइज़र है
test_888_0251-03 और फिर इसे जोड़ा
test_888_0252-01 और अब यहाँ हम एन के लिए बिल्कुल यही काम करते हैं
test_888_0253-01 तो
test_888_0253-02 हम एम्प्टी लिस्ट के साथ शुरू करते हैं
test_888_0253-03 और इस रेंज में प्रत्येक एन के फैक्टर जे के लिए
test_888_0254-01 यदि यह डिवाइड करता है
test_888_0254-02 तो हम इसे अपेण्ड करते हैं
test_888_0255-01 और अब
test_888_0255-02 इस बिंदु पर हमारे पास दो लिस्ट्स
test_888_0255-03 एफ एम और एफ एन हैं
test_888_0256-01 और अब हम कॉमन फैक्टर्स की लिस्ट कंप्यूट करना चाहते हैं
test_888_0257-01 इसलिए
test_888_0257-02 हम कॉमन फैक्टर्स की लिस्ट को दर्शाने के लिए
test_888_0257-03 सी एफ का उपयोग करते हैं
test_888_0257-04 शुरू में कोई कॉमन फैक्टर्स नहीं हैं
test_888_0258-01 अब
test_888_0258-02 पहली लिस्ट में हर फैक्टर के लिए
test_888_0259-01 यदि फैक्टर दूसरी लिस्ट में दिखाई देता है
test_888_0259-02 तो हम इसे सी एफ में अपेण्ड कर देते हैं
test_888_0260-01 तो
test_888_0260-02 एक ही फंक्शन अपेण्ड का उपयोग किया जा रहा है
test_888_0261-01 यह कहता है
test_888_0261-02 कि एक लिस्ट लें और एक वैल्यू जोड़ें
test_888_0262-01 हम उस वैल्यू को जोड़ते हैं
test_888_0262-02 जिसे हम अभी देख रहे हैं
test_888_0262-03 बशर्ते कि यह कंडीशन को संतुष्ट करे
test_888_0263-01 पहले हम जोड़ रहे थे
test_888_0263-02 बशर्ते कि डिवाइज़र शून्य था
test_888_0264-01 रिमाइंडर शून्य था
test_888_0264-02 अब हम इसे जोड़ रहे हैं
test_888_0264-03 बशर्ते दोनों लिस्ट में दिखाई दें
test_888_0265-01 पहली लिस्ट में प्रत्येक एफ के लिए
test_888_0265-02 यदि यह दूसरी लिस्ट में दिखाई देता है
test_888_0265-03 तो इसे जोड़ें
test_888_0266-01 तो
test_888_0266-02 इसके बाद हमने एफ एम कंप्यूट की है
test_888_0267-01 सी एफ
test_888_0268-01 और अब हम राइटमोस्ट एलिमेंट चाहते हैं
test_888_0269-01 तो
test_888_0269-02 यह सिर्फ कुछ पाइथन सिंटेक्स है
test_888_0269-03 जिसे आप देखेंगे जो कहता है कि
test_888_0270-01 इसके बजाय यदि हम बाईं ओर से काउंट शुरू करते हैं
test_888_0270-02 तो लिस्ट में पोसिशन्स की नंबर
test_888_0270-03 शून्य
test_888_0270-04 एक
test_888_0270-05 दो
test_888_0270-06 तीन
test_888_0270-07 चार होती है
test_888_0271-01 लेकिन पाइथन के पास एक शॉर्टकट है
test_888_0271-02 जो कहता है
test_888_0271-03 कि यदि आप दाईं ओर से काउंट करना चाहते हैं
test_888_0271-04 तो हम संख्याओं को माइनस एक
test_888_0271-05 माइनस दो
test_888_0271-06 और इतने पर गिनते हैं
test_888_0272-01 तो यह कहता है
test_888_0272-02 कि सी एफ का माइनस वन्थ एलिमेंट लौटाएं जो पाइथन जारगन में है
test_888_0272-03 जिसका अर्थ है
test_888_0272-04 राइटमोस्ट एलिमेंट लौटाएं
test_888_0272-05 तो यह राइटमोस्ट एलिमेंट है
test_888_0273-01 तो
test_888_0273-02 इस बिंदु पर यह समझने सकते है
test_888_0273-03 कि हम वास्तव में कोशिश कर सकते हैं
test_888_0273-04 और इस प्रोग्राम कोड को डी कोड कर सकते है
test_888_0274-01 भले ही हम ठीक से समझ नहीं पा रहे हों
test_888_0274-02 कि हम कुछ जगहों पर कोलन का इस्तेमाल क्यों कर रहे हैं
test_888_0274-03 और क्यों कुछ बातों को आगे बढ़ा रहे हैं
test_888_0275-01 देखें कि यहां अन्य सिंटैक्टिक चीजें हैं
test_888_0276-01 तो
test_888_0276-02 उदाहरण के लिए
test_888_0276-03 आपके पास ये पंक्चुएशन मार्क्स हैं
test_888_0276-04 जो इन कोलोन्स की तरह थोड़े अजीब हैं
test_888_0277-01 फिर आपके पास यह तथ्य है
test_888_0277-02 कि यह रेखा इस रेखा के संबंध में इंडेंटेड है
test_888_0278-01 यह लाइन इस लाइन के संबंध में इंडेंटेड है
test_888_0278-02 तो ये सभी विशेषताएं हैं
test_888_0278-03 जो अन्य भाषाओं के प्रोग्राम्स की तुलना में पाइथन प्रोग्राम्स को पढ़ने और लिखने में थोड़ा आसान बनाती हैं
test_888_0279-01 इसलिए
test_888_0279-02 हम इन पर आएंगे
test_888_0279-03 जब हम पायथन सिंटैक्स को अधिक औपचारिक रूप से सीखेंगे
test_888_0279-04 परन्तु
test_888_0280-01 इस बिंदु पर
test_888_0280-02 हमें खुद को यह समझाने में सक्षम होना चाहिए
test_888_0280-03 कि पायथन स्टेप्स का यह सेट अनौपचारिक अल्गोरिथम का एक बहुत ही वफादार प्रतिपादन है
test_888_0280-04 जो हमने पिछली स्लाइड में लिखा था
test_888_0281-01 तो चलिए कुछ पॉइंट्स पर ध्यान दें
test_888_0281-02 कि हम पहले से ही इस विशेष उदाहरण से निकाल सकते हैं
test_888_0282-01 इसलिए
test_888_0282-02 पहला महत्वपूर्ण पॉइंट यह है
test_888_0282-03 कि हमें इंटरमीडिएट वैल्यूज पर नज़र रखने के लिए एक तरीका चाहिए
test_888_0283-01 इसलिए
test_888_0283-02 हमारे पास अपने आर्ग्यूमेंट्स एम और एन के नेम्स के साथ शुरू करने के लिए दो नेम्स हैं
test_888_0284-01 फिर हम इन तीन नेम्स का उपयोग
test_888_0284-02 फैक्टर्स और सामान्य फैक्टर्स की इन सूचियों की कम्प्यूटेशन करने के लिए करते हैं
test_888_0285-01 और हम अन्य नेम्स का उपयोग करते हैं
test_888_0285-02 जैसे आई
test_888_0285-03 जे
test_888_0285-04 एंड एफ
test_888_0285-05 इनसे चलाने के लिए
test_888_0285-06 एक से एम तक चलने के लिए हमें आई की आवश्यकता है
test_888_0286-01 हमें जे को एक से एन तक चलाने की जरूरत है
test_888_0286-02 हम आई पुनउपयोग कर सकते हैं
test_888_0286-03 लेकिन यह ठीक है
test_888_0287-01 हम सी एफ में सभी फैक्टर्स से चलाने के लिए
test_888_0287-02 एफ का उपयोग करते हैं
test_888_0288-01 तो
test_888_0288-02 ये सभी इंटरमीडिएट वैल्यूज पर नज़र रखने के तरीके हैं
test_888_0289-01 ध्यान देने योग्य दूसरा पॉइंट यह है
test_888_0289-02 कि एक वैल्यू एक ही आइटम हो सकता है
test_888_0290-01 उदाहरण के लिए
test_888_0290-02 एम
test_888_0290-03 एन नंबर हैं
test_888_0291-01 इसी तरह
test_888_0291-02 मैं
test_888_0291-03 जे और एफ प्रत्येक स्टेप में नंबर्स हैं
test_888_0292-01 ये सिंगल वैल्यूज हो सकते हैं
test_888_0293-01 या वे संग्रह हो सकते हैं
test_888_0293-02 तो लिस्ट्स हैं
test_888_0294-01 तो
test_888_0294-02 एफ एम एक लिस्ट है
test_888_0294-03 एफ एन एक लिस्ट है
test_888_0295-01 तो
test_888_0295-02 यह इस मामले में वैल्यूज के कलेक्शन को दर्शाने वाला एक सिंगल नेम है
test_888_0295-03 एक लिस्ट
test_888_0295-04 एक सीक्वेंस इसमें पहली पोसिशन और अगली पोसिशन और एक अंतिम पोसिशन है
test_888_0296-01 तो
test_888_0296-02 ये संख्याओं की लिस्ट हैं
test_888_0297-01 अन्य कलेक्शंस की कल्पना कर सकते हैं
test_888_0297-02 और हम उन्हें देखेंगे
test_888_0298-01 तो
test_888_0298-02 कलेक्शंस महत्वपूर्ण हैं
test_888_0298-03 क्योंकि प्रोग्राम लिखना बहुत मुश्किल होगा
test_888_0299-01 यदि हमें अलग से एम के हर फैक्टर के लिए
test_888_0299-02 एक नेम का उत्पादन करते रहना था
test_888_0299-03 तो हमें एम के सभी फैक्टर्सों के लिए सामूहिक रूप से
test_888_0299-04 एक नेम की आवश्यकता होती है
test_888_0299-05 भले ही एम कितना बड़ा हो
test_888_0300-01 इसलिए
test_888_0300-02 ये नेम्स सिंगल वैल्यू या वैल्यूज के कलेक्शंस को दर्शाते हैं
test_888_0300-03 और एक विशेष स्ट्रक्चर के साथ वैल्यूज का एक कलेक्शंस ठीक वही है
test_888_0300-04 जिसे हम डेटा स्ट्रक्चर कहते हैं
test_888_0301-01 इसलिए
test_888_0301-02 इन्हें आमतौर पर डेटा स्ट्रक्चर कहा जाता है
test_888_0301-03 तो
test_888_0301-04 इस मामले में डाटा स्ट्रक्चर जो हमारे पास है
test_888_0301-05 वह एक लिस्ट है
test_888_0302-01 तो
test_888_0302-02 हम इन नेम्स और वैल्यूज का क्या कर सकते हैं
test_888_0302-03 एक बात यह है
test_888_0302-04 कि हम एक नेम्स के लिए एक वैल्यू असाइन कर सकते हैं
test_888_0303-01 इसलिए
test_888_0303-02 उदाहरण के लिए
test_888_0303-03 जब हम लिखते हैं
test_888_0303-04 कि एफ एन खाली लिस्ट के बराबर है
test_888_0303-05 तो हम स्पष्ट रूप से एफ एन के वैल्यू को खाली लिस्ट में स्थापित कर रहे हैं
test_888_0304-01 यह दो बातों को बताता है
test_888_0304-02 कि वैल्यू एक खाली लिस्ट है
test_888_0304-03 यह पाइथन को यह भी बताता है
test_888_0304-04 कि एफ एन एक लिस्ट है
test_888_0305-01 तो
test_888_0305-02 ये दो स्टेप्स हैं
test_888_0305-03 जैसा हम देखेंगे
test_888_0306-01 और दूसरा हिस्सा यह है
test_888_0306-02 कि जब हम कुछ ऐसा लिखते हैं
test_888_0306-03 लिस्ट सी एफ में प्रत्येक एफ के लिए
test_888_0307-01 यह स्पष्ट रूप से कह रहा है
test_888_0307-02 कि सी एफ में हर वैल्यू लें और इसे एक एक करके वैल्यू एफ का नेम दें
test_888_0308-01 इसलिए
test_888_0308-02 हालांकि हमारे पास यह इक्वालिटी का संकेत स्पष्ट रूप से नहीं है
test_888_0308-03 यह एफ के लिए एक नया वैल्यू असाइन कर रहा है
test_888_0308-04 क्योंकि हम लिस्ट सी एफ के स्टेप्स से देखते हैं
test_888_0309-01 तो
test_888_0309-02 मुख्य बात यह है
test_888_0309-03 कि हम एक पाइथन प्रोग्राम में वैल्यूज को नेम्स को असाइन करते हैं
test_888_0310-01 और एक वैल्यू असाइन होने के बाद
test_888_0310-02 हम वैल्यू को संशोधित कर सकते हैं
test_888_0311-01 उदाहरण के लिए
test_888_0311-02 हर बार जब हम एन का एक नया फैक्टर ढूंढते हैं
test_888_0311-03 तो हम पुराने फैक्टर को फेंक देना नहीं चाहते हैं
test_888_0311-04 उसे हम मौजूदा लिस्ट एफ एन से जोड़ लेना चाहते हैं
test_888_0312-01 इसलिए
test_888_0312-02 उदाहरण के लिए
test_888_0312-03 यह कार्य एफ एन नेम के वैल्यू को एक नए नेम्स में संशोधित करता है
test_888_0312-04 जो पुराने नेम को लेता है
test_888_0312-05 और इसके अंत में आई को जोड़ता है
test_888_0313-01 इसलिए
test_888_0313-02 आम तौर पर हमारे पास एक नंबर आई हो सकती है
test_888_0313-03 और हम इसे इसके दो गुना से बदलना चाहते हैं
test_888_0314-01 इसलिए
test_888_0314-02 हमारे पास कुछ ऐसा हो सकता है
test_888_0314-03 जैसे मैं दो बार के बराबर हूं
test_888_0315-01 तो
test_888_0315-02 स्टार गुणा के लिए है
test_888_0316-01 इसका मतलब यह नहीं है
test_888_0316-02 कि यह दो बार आई अरिथमेटिकली के बराबर हैं
test_888_0317-01 क्योंकि जाहिर है
test_888_0317-02 जब तक आई शून्य नहीं होता
test_888_0317-03 आई दो गुना के बराबर नहीं हो सकता
test_888_0318-01 इसका मतलब यह है
test_888_0318-02 कि आई का वर्तमान वैल्यू लें
test_888_0319-01 इसे दो से गुणा करें और इसे आई को असाइन करें
test_888_0319-02 इसलिए
test_888_0319-03 हम इसे देखेंगे असाइन मेंट या तो पूरी तरह से नया वैल्यू असाइन कर सकता है
test_888_0319-04 या यह पुराने वैल्यू का उपयोग करके वैल्यू को अपडेट कर सकता है
test_888_0320-01 इसलिए यहां हम लिस्ट के फंक्शन का पुराना वैल्यू एफ एन ले रहे हैं
test_888_0321-01 और हम इस से एक वैल्यू अपेण्ड कर रहे हैं
test_888_0321-02 और एफ एन का एक नया वैल्यू प्राप्त कर रहे हैं
test_888_0322-01 दूसरा हिस्सा जो हमें ध्यान देने की आवश्यकता है
test_888_0322-02 कि हम हर स्टेप को कैसे एक्सेक्यूट करते हैं
test_888_0323-01 तो जैसा कि हमने आज के व्याख्यान की शुरुआत में कहा था
test_888_0323-02 एक प्रोग्राम स्टेप्स का एक सीक्वेंस है
test_888_0324-01 लेकिन हम सिर्फ स्टेप्स को शुरू से अंत तक एक्सेक्यूट नहीं कर सकते हैं
test_888_0325-01 कभी कभी यही काम हमें बार बार करना पड़ता है
test_888_0326-01 उदाहरण के लिए
test_888_0326-02 हमें एक से एम तक हर संभव फैक्टर्स की जांच करनी होगी
test_888_0326-03 अगर यह एम को डिवाइड करता है
test_888_0326-04 फिर इसे लिस्ट में डाल देते है
test_888_0327-01 तो
test_888_0327-02 कुछ स्टेप्स दोहराए जाते हैं
test_888_0328-01 हम उदाहरण के लिए कुछ करते हैं
test_888_0328-02 यहां एक लिस्ट में प्रत्येक आइटम के लिए
test_888_0329-01 कुछ स्टेप्स को तभी एक्सेक्यूट किया जाता है
test_888_0329-02 जब हम जिस वैल्यू को देख रहे हैं
test_888_0329-03 वह एक विशेष कंडीशन को पूरा करता है
test_888_0330-01 इसलिए
test_888_0330-02 जब हम कुछ ऐसा कहते हैं
test_888_0330-03 जैसे कि एम परसेंट आई शून्य है
test_888_0331-01 यदि आई द्वारा एम डिवीज़न पर रिमाइंडर शून्य है
test_888_0331-02 तो अपेण्ड
test_888_0332-01 तो
test_888_0332-02 स्टेप अपेण्ड आई तो एफ एम तभी होता है
test_888_0332-03 जब आई इस शर्त से मेल खाता है
test_888_0332-04 कि यह एम का फैक्टर है
test_888_0333-01 इसलिए
test_888_0333-02 हमने बार बार ऐसे स्टेप्स उठाए हैं
test_888_0333-03 जहां एक ही काम बार बार होता है
test_888_0334-01 और हमारे पास कंडीशनल स्टेप्स हैं
test_888_0334-02 जो किसी विशेष कंडीशन के होने पर ही किया जाता है
test_888_0335-01 तो
test_888_0335-02 हम यहीं रुकेंगे
test_888_0335-03 इस उदाहरण को आपको देखना चाहिए कि प्रोग्राम हम जो जानते हैं
test_888_0335-04 उससे बहुत अलग नहीं हैं
test_888_0336-01 यह केवल उन्हें सही ढंग से लिखने का सवाल है
test_888_0337-01 और यह सुनिश्चित करना कि हम उन सभी इंटरमीडिएट वैल्यूज और कदमों पर नज़र रखें जिनकी हमें आवश्यकता है
test_888_0337-02 क्योंकि हम चीजों को खो सकते हैं
test_888_0338-01 हम इस उदाहरण को और विस्तार से देखेंगे
test_888_0338-02 और इसे लिखने के अन्य तरीके खोजने की कोशिश करेंगे
test_888_0339-01 और अन्य सुविधाओं की जांच करेंगे
test_888_0339-02 लेकिन अनिवार्य रूप से यह प्रोग्रामिंग को चित्रित करने का एक अच्छा तरीका है